arXiv:0902.2206v5 [cs.AI] 27 Feb 2010

Feature Hashing for Large Scale Multitask Learning

Kilian Weinberger
Anirban Dasgupta
Josh Attenberg
John Langford
Alex Smola
Yahoo! Research, 2821 Mission College Blvd., Santa Clara, CA 95051 USA

KILIAN @ YAHOO - INC . COM
ANIRBAN @ YAHOO - INC . COM
JOSH @ CIS . POLY. EDU
JL @ HUNCH . NET
ALEX @ SMOLA . ORG

Keywords: kernels, concentration inequalities, document classification, classifier personalization, multitask learning

Abstract

frequently encounter the opposite problem: the original input space is almost linearly separable (often because of the
existence of handcrafted non-linear features), yet, the training set may be prohibitively large in size and very high dimensional. In such a case, there is no need to map the input
vectors into a higher dimensional feature space. Instead,
limited memory makes storing a kernel matrix infeasible.

Empirical evidence suggests that hashing is an
effective strategy for dimensionality reduction
and practical nonparametric estimation. In this
paper we provide exponential tail bounds for feature hashing and show that the interaction between random subspaces is negligible with high
probability. We demonstrate the feasibility of
this approach with experimental results for a new
use case — multitask learning with hundreds of
thousands of tasks.

1. Introduction
Kernel methods use inner products as the basic tool for
comparisons between objects. That is, given objects
x1 , . . . , xn ∈ X for some domain X, they rely on
k(xi , xj ) := hφ(xi ), φ(xj )i

(1)

to compare the features φ(xi ) of xi and φ(xj ) of xj respectively.
Eq. (1) is often famously referred to as the kernel-trick. It
allows the use of inner products between very high dimensional feature vectors φ(xi ) and φ(xj ) implicitly through
the definition of a positive semi-definite kernel matrix k
without ever having to compute a vector φ(xi ) directly.
This can be particularly powerful in classification settings
where the original input representation has a non-linear decision boundary. Often, linear separability can be achieved
in a high dimensional feature space φ(xi ).
In practice, for example in text classification, researchers
Preliminary work. Under review by the International Conference
on Machine Learning (ICML). Do not distribute.

For this common scenario several authors have recently
proposed an alternative, but highly complimentary variation of the kernel-trick, which we refer to as the
hashing-trick: one hashes the high dimensional input vectors x into a lower dimensional feature space Rm with
φ : X → Rm (Langford et al., 2007; Shi et al., 2009). The
parameter vector of a classifier can therefore live in Rm
instead of in Rn with kernel matrices or Rd in the original input space, where m ≪ n and m ≪ d. Different
from random projections, the hashing-trick preserves sparsity and introduces no additional overhead to store projection matrices.
To our knowledge, we are the first to provide exponential
tail bounds on the canonical distortion of these hashed inner
products. We also show that the hashing-trick can be particularly powerful in multi-task learning scenarios where the
original feature spaces are the cross-product of the data, X,
and the set of tasks, U . We show that one can use different
hash functions for each task φ1 , . . . , φ|U| to map the data
into one joint space with little interference.
While many potential applications exist for the hashingtrick, as a particular case study we focus on collaborative
email spam filtering. In this scenario, hundreds of thousands of users collectively label emails as spam or notspam, and each user expects a personalized classifier that
reflects their particular preferences. Here, the set of tasks,
U , is the number of email users (this can be very large for
open systems such as Yahoo MailTM or GmailTM ), and the
feature space spans the union of vocabularies in multitudes

Feature Hashing for Large Scale Multitask Learning

of languages.
This paper makes four main contributions: 1. In section 2 we introduce specialized hash functions with unbiased inner-products that are directly applicable to a large
variety of kernel-methods. 2. In section 3 we provide exponential tail bounds that help explain why hashed feature vectors have repeatedly lead to, at times surprisingly,
strong empirical results. 3. Also in section 3 we show that
the interference between independently hashed subspaces
is negligible with high probability, which allows large-scale
multi-task learning in a very compressed space. 4. In section 5 we introduce collaborative email-spam filtering as a
novel application for hash representations and provide experimental results on large-scale real-world spam data sets.

2. Hash Functions
We introduce a variant on the hash kernel proposed by (Shi
et al., 2009). This scheme is modified through the introduction of a signed sum of hashed features whereas the original
hash kernels use an unsigned sum. This modification leads
to an unbiased estimate, which we demonstrate and further
utilize in the following section.
Definition 1 Denote by h a hash function h : N →
{1, . . . , m}. Moreover, denote by ξ a hash function ξ :
N → {±1}. Then for vectors x, x′ ∈ ℓ2 we define the
hashed feature map φ and the corresponding inner product
as
X
(h,ξ)
ξ(i)xi
(2)
φi (x) =
j:h(j)=i

D

E
and hx, x′ iφ := φ(h,ξ) (x), φ(h,ξ) (x′ ) .

(3)

Although the hash functions in definition 1 are defined over
the natural numbers N, in practice we often consider hash
functions over arbitrary strings. These are equivalent, since
each finite-length string can be represented by a unique natural number.

present paper continues where (Shi et al., 2009) falls short:
we prove exponential tail bounds. These bounds hold for
general hash kernels, which we later apply to show how
hashing enables us to do large-scale multitask learning efficiently. We start with a simple lemma about the bias and
variance of the hash kernel. The proof of this lemma appears in appendix A.
Lemma 2 The hash kernel is unbiased, that is
Eφ [hx, x′ iφ ] = hx, x′ i. Moreover, the variance is


1 P
′
′
2 ′2
2
σx,x
= m
′
i6=j xi xj + xi xi xj xj , and thus, for

1
2
kxk2 = kx′ k2 = 1, σx,x
′ = O
m .

This suggests that typical values of the hash kernel should
be concentrated within O( √1m ) of the target value. We use
Chebyshev’s inequality
√to show that half of all observations
are within a range of 2σ. This, together with an indirect
application of Talagrand’s convex distance inequality via
the result of (Liberty et al., 2008), enables us to construct
exponential tail bounds.
3.1. Concentration of Measure Bounds
In this subsection we show that under a hashed feature-map
the length of each vector is preserved with high probability.
Talagrand’s inequality (Ledoux, 2001) is a key tool for the
proof of the following theorem (detailed in the appendix B).
Theorem 3 Let ǫ < 1 be a fixed constant and x be a given
instance such that kxk2 = 1. If m ≥ 72 log(1/δ)/ǫ2 and
ǫ
kxk∞ ≤ √
, we have that
18

log(1/δ) log(m/δ)

Pr[|kxk2φ − 1| ≥ ǫ] ≤ 2δ.

(4)

Note that an analogous result would also hold for the original hash kernel of (Shi et al., 2009), the only modification being the associated bias terms. The above result can
also be utilized to show a concentration bound on the inner
product between two general vectors x and x′ .

Usually, we abbreviate the notation φ(h,ξ) (·) by just φ(·).
Two hash functions φ and φ′ are different when φ = φ(h,ξ)
′ ′
and φ′ = φ(h ,ξ ) such that either h′ 6= h or ξ 6= ξ ′ . The
purpose of the binary hash ξ is to remove the bias inherent
in the hash kernel of (Shi et al., 2009).

Corollary 4 For two vectors x and x′ , let us define

In a multi-task setting, we obtain instances in combination
with tasks, (x, u) ∈ X × U . We can naturally extend our
definition 1 to hash pairs, and will write φu (x) = φ(x, u).

Also let ∆ = kxk2 + kx′ k2 + kx − x′ k2 . If m ≥
ǫ
), then we have that
Ω( ǫ12 log(1/δ)) and η = O( log(m/δ)

3. Analysis
The following section is dedicated to theoretical analysis
of hash kernels and their applications. In this sense, the

σ := max(σx,x , σx′ ,x′ , σx−x′ ,x−x′ )


kxk∞ kx′ k∞ kx − x′ k∞
η := max
.
,
,
kxk2 kx′ k2 kx − x′ k2

h
i
Pr | hx, x′ iφ −hx, x′ i | > ǫ∆/2 < δ.
The proof for this corollary can be found in appendix C. We
can also extend the bound in Theorem 3 for the maximal

Feature Hashing for Large Scale Multitask Learning

canonical distortion over large sets of distances between
vectors as follows:
Corollary 5 If m ≥ Ω( ǫ12 log(n/δ)) and η =
ǫ
). Denote by X = {x1 , . . . , xn } a set of vectors
O( log(m/δ)
which satisfy kxi − xj k∞ ≤ η kxi − xj k2 for all pairs i, j.
In this case with probability 1 − δ we have for all i, j
2

2

| kxi − xj kφ − kxi − xj k2 |
kxi − xj k22

≤ ǫ.

This means that the number of observations n (or correspondingly the size of the un-hashed kernel matrix) only
enters logarithmically in the analysis.
Proof We apply the bound of Theorem 3 to each distance
individually. Note that each vector xi − xj satisfies the
conditions of the theorem, and hence for each vector xi −
xj , we preserve the distance upto a factor of (1 ± ǫ) with
probability 1 − nδ2 . Taking the union bound over all pairs
gives us the result.

Note that the tightness of the union bound in Corollary 5
depends crucially on the magnitude of η. In other words,
for large values of η, that is, whenever some terms in x
are very large, even a single collision can already lead to
significant distortions of the embedding. This issue can
be amended by trading off sparsity with variance. A vector of unit lengthmay be written as (1, 0, 0, 0, . . .), or
√1 , √1 , 0, . . .
2
2

, or more generally as a vector with c
1

nonzero terms of magnitude c− 2 . This is relevant, for instance whenever the magnitudes of x follow a known pattern, e.g. when representing documents as bags of words
since we may simply hash frequent words several times.
The following corollary gives an intuition as to how the
confidence bounds scale in terms of the replications:
Lemma 6 If we let x′ =

Theorem 7 Let w ∈ Rm be a parameter vector for tasks
in U \ {u}. In this case the value of the inner product
hw, φu (x)i is bounded by
Pr {|hw, φu (x)i| > ǫ} ≤ 2e

√1 (x, . . . , x)
c

−

ǫ2 /2
m−1 kwk2 kxk2 +ǫkwk∞ kxk∞ /3
2
2

Proof We use Bernstein’s inequality (Bernstein, 1946),
which states that for independent random variables Xj ,
with E [Xj ] = 0, if C > 0 is such that |Xj | ≤ C, then


Pr 

3.2. Multiple Hashing

as

hash-feature space we want to ensure that there is little interaction between the different parameter vectors. Let U be
a set of different tasks, u ∈ U being a specific one. Let w be
a combination of the parameter vectors of tasks in U \ {u}.
We show that for any observation x for task u, the interaction of w with x in the hashed feature space is minimal.
For each x, let the image of x under the hash feature-map
for task u be denoted as φu (x) = φ(ξ,h) ((x, u)).

n
X
j=1



!
t2 /2
 2
. (5)
j=1 E Xj + Ct/3

Xj > t ≤ exp − Pn

We have to compute
P the concentration property of
hw, φu (x)i =
j xj ξ(j)wh(j) . Let Xj = xj ξ(j)wh(j) .
By the definition of h and ξ, Xj are independent. Also,
for each j, since w depends only on the hash-functions for
U \ {u},
of ξ(j). Thus, E[Xj ] =
 wh (j) is independent

E(ξ,h) xj ξ(j)wh(j) = 0. For
each
j, we also have |Xj | <
P
kxk∞ kwk∞ =: C. Finally, j E[Xj2 ] is given by


X
E  (xj ξ(j)wh(j) )2  =
j

1
m

X
j,ℓ

x2j wℓ2 =

1
m

2

2

kxk2 kwk2

The claim follows by plugging both terms and C into the
Bernstein inequality (5).

then:

1. It is norm preserving: kxk2 = kx′ k2 .
2. It reduces component magnitude by

√1
c

=

kx′ k∞
kxk∞

.

4

2
+ c−1
3. Variance increases to σx2′ ,x′ = 1c σx,x
c 2 kxk2 .

Applying Lemma 6 to Theorem 3, a large magnitude can
be decreased at the cost of an increased variance.
3.3. Approximate Orthogonality
For multitask learning, we must learn a different parameter
vector for each related task. When mapped into the same

Theorem 7 bounds the influence of unrelated tasks with any
particular instance. In section 5 we demonstrate the realworld applicability with empirical results on a large-scale
multi-task learning problem.

4. Applications
The advantage of feature hashing is that it allows for significant storage compression for parameter vectors: storing
w in the raw feature space naively requires O(d) numbers,
when w ∈ Rd . By hashing, we are able to reduce this to
O(m) numbers while avoiding costly matrix-vector multiplications common in Locally Sensitive Hashing. In addition, the sparsity of the resulting vector is preserved.

Feature Hashing for Large Scale Multitask Learning

The benefits of the hashing-trick leads to applications in
almost all areas of machine learning and beyond. In particular, feature hashing is extremely useful whenever large
numbers of parameters with redundancies need to be stored
within bounded memory capacity.
Personalization One powerful application of feature
hashing is found in multitask learning. Theorem 7 allows
us to hash multiple classifiers for different tasks into one
feature space with little interaction. To illustrate, we explore this setting in the context of spam-classifier personalization.
Suppose we have thousands of users U and want to perform related but not identical classification tasks for each
of the them. Users provide labeled data by marking emails
as spam or not-spam. Ideally, for each user u ∈ U , we
want to learn a predictor wu based on the data of that user
solely. However, webmail users are notoriously lazy in labeling emails and even those that do not contribute to the
training data expect a working spam filter. Therefore, we
also need to learn an additional global predictor w0 to allow
data sharing amongst all users.
Storing all predictors wi requires O(d × (|U | + 1)) memory. In a task like collaborative spam-filtering, |U |, the
number of users can be in the hundreds of thousands and
the size of the vocabulary is usually in the order of millions. The naive way of dealing with this is to eliminate all infrequent tokens. However, spammers target this
memory-vulnerability by maliciously misspelling words
and thereby creating highly infrequent but spam-typical
tokens that “fall under the radar” of conventional classifiers. Instead, if all words are hashed into a finite-sized
feature vector, infrequent but class-indicative tokens get a
chance to contribute to the classification outcome. Further,
large scale spam-filters (e.g. Yahoo MailTM or GMailTM )
typically have severe memory and time constraints, since
they have to handle billions of emails per day. To guarantee a finite-size memory footprint we hash all weight vectors w0 , . . . , w|U| into a joint, significantly smaller, feature
space Rm with different hash functions φ0 , . . . , φ|U| . The
resulting hashed-weight vector wh ∈ Rm can then be written as:
X
wh = φ0 (w0 ) +
φu (wu ).
(6)

ǫi . More precisely:
hφ0 (x) + φu (x), wh i = hx, w0 + wu i + ǫd + ǫi .

(7)

The interference error consists of all collisions between
φ0 (x) or φu (x) with hash functions of other users,
X
X
ǫi =
hφ0 (x), φv (wv )i +
hφu (x), φv (wv )i . (8)
v∈U,v6=0

v∈U,v6=u

To show that ǫi is small with high probability we can
apply Theorem 7 twice, once for each term of (8).
We consider each
P user’s classification to be a separate
task, and since v∈U,v6=0 wv is independent of the hashfunction
φ0 , the conditions of Theorem 7 apply with w =
P
w
Pv6=0 v and we can employ it to bound the second term,
The second application is
v∈U,v6=0 hφu (x), φu (wv )i.
identical except that all subscripts “0” are substituted with
“u”. For lack of space we do not derive the exact bounds.
The distortion error occurs because each hash function that
is utilized by user u can self-collide:
X
| hφv (x), φv (wv )i − hx, wv i |.
(9)
ǫd =
v∈{u,0}

To show that ǫd is small with high probability, we apply
Corollary 4 once for each possible values of v.
In section 5 we show experimental results for this setting. The empirical results are stronger than the theoretical
bounds derived in this subsection—our technique outperforms a single global classifier on hundreds thousands of
users. We discuss an intuitive explanation in section 5.
Massively Multiclass Estimation We can also regard
massively multi-class classification as a multitask problem,
and apply feature hashing in a way similar to the personalization setting. Instead of using a different hash function for each user, we use a different hash function for each
class.
(Shi et al., 2009) apply feature hashing to problems with
a high number of categories. They show empirically that
joint hashing of the feature vector φ(x, y) can be efficiently
achieved for problems with millions of features and thousands of classes.

u∈U

Note that in practice the weight vector wh can be learned
directly in the hashed space. All un-hashed weight vectors
never need to be computed. Given a new document/email
x of user u ∈ U , the prediction task now consists of calculating hφ0 (x) + φu (x), wh i. Due to hashing we have two
sources of error – distortion ǫd of the hashed inner products and the interference with other hashed weight vectors

Collaborative Filtering Assume that we are given a very
large sparse matrix M where the entry Mij indicates what
action user i took on instance j. A common example for
actions and instances is user-ratings of movies (Bennett &
Lanning, ). A successful method for finding common factors amongst users and instances for predicting unobserved
actions is to factorize M into M = U ⊤ W . If we have
millions of users performing millions of actions, storing U

Feature Hashing for Large Scale Multitask Learning

Figure 1. The hashed personalization summarized in a schematic
layout. Each token is duplicated and one copy is individualized
(e.g. by concatenating each word with a unique user identifier).
Then, the global hash function maps all tokens into a low dimensional feature space where the document is classified.

and W in memory quickly becomes infeasible. Instead, we
may choose to compress the matrices U and W using hashing. For U, W ∈ Rn×d denote by u, w ∈ Rm vectors with
ui =

X

ξ(j, k)Ujk and wi =

X

ξ ′ (j, k)Wjk .

j,k:h′ (j,k)=i

j,k:h(j,k)=i

where (h, ξ) and (h′ , ξ ′ ) are independently chosen hash
functions. This allows us to approximate matrix elements
Mij = [U ⊤ W ]ij via
Mijφ :=

X

ξ(k, i)ξ ′ (k, j)uh(k,i) wh′ (k,j) .

k

This gives a compressed vector representation of M that
can be efficiently stored.

5. Results
We evaluated our algorithm in the setting of personalization. As data set, we used a proprietary email spamclassification task of n = 3.2 million emails, properly
anonymized, collected from |U | = 433167 users. Each
email is labeled as spam or not-spam by one user in U . After tokenization, the data set consists of 40 million unique
words.
For all experiments in this paper, we used the Vowpal Wabbit implementation1 of stochastic gradient descent on a
square-loss. In the mail-spam literature the misclassification of not-spam is considered to be much more harmful
than misclassification of spam. We therefore follow the
convention to set the classification threshold during test
time such that exactly 1% of the not − spam test data is
classified as spam Our implementation of the personalized
hash functions is illustrated in Figure 1. To obtain a personalized hash function φu for user u, we concatenate a unique
user-id to each word in the email and then hash the newly
generated tokens with the same global hash function.
1

Figure 2. The decrease of uncaught spam over the baseline classifier averaged over all users. The classification threshold was
chosen to keep the not-spam misclassification fixed at 1%.
The hashed global classifier (global-hashed) converges relatively
soon, showing that the distortion error ǫd vanishes. The personalized classifier results in an average improvement of up to 30%.

http://hunch.net/∼vw/

The data set was collected over a span of 14 days. We
used the first 10 days for training and the remaining 4 days
for testing. As baseline, we chose the purely global classifier trained over all users and hashed into 226 dimensional
space. As 226 far exceeds the total number of unique words
we can regard the baseline to be representative for the classification without hashing. All results are reported as the
amount of spam that passed the filter undetected, relative
to this baseline (eg. a value of 0.80 indicates a 20% reduction in spam for the user)2 .
Figure 2 displays the average amount of spam in users’ inboxes as a function of the number of hash keys m, relative
to the baseline above. In addition to the baseline, we evaluate two different settings.
The global-hashed curve represents the relative
spam catch-rate of the global classifier after hashing
hφ0 (w0 ), φ0 (x)i. At m = 226 this is identical to the
baseline. Early convergence at m = 222 suggests that at
this point hash collisions have no impact on the classification error and the baseline is indeed equivalent to that
obtainable without hashing.
In the personalized setting each user u ∈ U gets her own
classifier φu (wu ) as well as the global classifier φ0 (w0 ).
Without hashing the feature space explodes, as the cross
product of u = 400K users and n = 40M tokens results
in 16 trillion possible unique personalized features. Figure 2 shows that despite aggressive hashing, personalization results in a 30% spam reduction once the hash table is
indexed by 22 bits.
2
As part of our data sharing agreement, we agreed not to include absolute classification error-rates.

Feature Hashing for Large Scale Multitask Learning

represents the common definition of spam and not-spam.
In other words, the global part of the personalized classifier obtains better generalization properties, benefiting all
users.

6. Related Work
A number of researchers have tackled related, albeit different problems.

Figure 3. Results for users clustered by training emails. For example, the bucket [8, 15] consists of all users with eight to fifteen
training emails. Although users in buckets with large amounts of
training data do benefit more from the personalized classifier (upto 65% reduction in spam), even users that did not contribute to
the training corpus at all obtain almost 20% spam-reduction.

User clustering One hypothesis for the strong results in
Figure 2 might originate from the non-uniform distribution
of user votes — it is possible that using personalization and
feature hashing we benefit a small number of users who
have labeled many emails, degrading the performance of
most users (who have labeled few or no emails) in the process. In fact, in real life, a large fraction of email users do
not contribute at all to the training corpus and only interact
with the classifier during test time. The personalized version of the test email Φu (xu ) is then hashed into buckets
of other tokens and only adds interference noise ǫi to the
classification.
In order to show that we improve the performance of most
users, it is therefore important that we not only report averaged results over all emails, but explicitly examine the
effects of the personalized classifier for users depending
on their contribution to the training set. To this end, we
place users into exponentially growing buckets based on
their number of training emails and compute the relative
reduction of uncaught spam for each bucket individually.
Figure 3 shows the results on a per-bucket basis. We do not
compare against a purely local approach, with no global
component, since for a large fraction of users—those without training data—this approach cannot outperform random guessing.
It might appear rather surprising that users in the bucket
with none or very little training emails (the line of bucket
[0] is identical to bucket [1]) also benefit from personalization. After all, their personalized classifier was never
trained and can only add noise at test-time. The classifier
improvement of this bucket can be explained by the subjective definition of spam and not-spam. In the personalized setting the individual component of user labeling is
absorbed by the local classifiers and the global classifier

(Rahimi & Recht, 2008) use Bochner’s theorem and sampling to obtain approximate inner products for Radial Basis Function kernels. (Rahimi & Recht, 2009) extend this
to sparse approximation of weighted combinations of basis functions. This is computationally efficient for many
function spaces. Note that the representation is dense.
(Li et al., 2007) take a complementary approach: for sparse
feature vectors, φ(x), they devise a scheme of reducing the
number of nonzero terms even further. While this is in principle desirable, it does not resolve the problem of φ(x) being high dimensional. More succinctly, it is necessary to
express the function in the dual representation rather than
expressing f as a linear function, where w is unlikely to be
compactly represented: f (x) = hφ(x), wi.
(Achlioptas, 2003) provides computationally efficient randomization schemes for dimensionality reduction. Instead
of performing a dense d·m dimensional matrix vector multiplication to reduce the dimensionality for a vector of dimensionality d to one of dimensionality m, as is required
by the algorithm of (Gionis et al., 1999), he only requires 31
of that computation by designing a matrix consisting only
of entries {−1, 0, 1}. Pioneered by (Ailon & Chazelle,
2006), there has been a line of work (Ailon & Liberty,
2008; Matousek, 2008) on improving the complexity of
random projection by using various code-matrices in order to preprocess the input vectors. Some of our theoretical
bounds are derivable from that of (Liberty et al., 2008).
A related construction is the CountMin sketch of (Cormode & Muthukrishnan, 2004) which stores counts in
a number of replicates of a hash table. This leads to good
concentration inequalities for range and point queries.
(Shi et al., 2009) propose a hash kernel to deal with the issue of computational efficiency by a very simple algorithm:
high-dimensional vectors are compressed by adding up all
coordinates which have the same hash value — one only
needs to perform as many calculations as there are nonzero
terms in the vector. This is a significant computational saving over locality sensitive hashing (Achlioptas, 2003; Gionis et al., 1999).
Several additional works provide motivation for the investigation of hashing representations. For example, (Ganchev
& Dredze, 2008) provide empirical evidence that the hash-

Feature Hashing for Large Scale Multitask Learning

ing trick can be used to effectively reduce the memory
footprint on many sparse learning problems by an order of
magnitude via removal of the dictionary. Our experimental results validate this, and show that much more radical
compression levels are achievable. In addition, (Langford
et al., 2007) released the Vowpal Wabbit fast online learning software which uses a hash representation similar to
that discussed here.

7. Conclusion
In this paper we analyze the hashing-trick for dimensionality reduction theoretically and empirically. As part of our
theoretical analysis we introduce unbiased hash functions
and provide exponential tail bounds for hash kernels. These
give further inside into hash-spaces and explain previously
made empirical observations. We also derive that random
subspaces of the hashed space are likely to not interact,
which makes multitask learning with many tasks possible.
Our empirical results validate this on a real-world application within the context of spam filtering. Here we demonstrate that even with a very large number of tasks and
features, all mapped into a joint lower dimensional hashspace, one can obtain impressive classification results with
finite memory guarantee.

References
Achlioptas, D. (2003). Database-friendly random projections: Johnson-lindenstrauss with binary coins. Journal
of Computer and System Sciences, 66, 671–687.
Ailon, N., & Chazelle, B. (2006). Approximate nearest
neighbors and the fast Johnson-Lindenstrauss transform.
Proc. 38th Annual ACM Symposium on Theory of Computing (pp. 557–563).
Ailon, N., & Liberty, E. (2008). Fast dimension reduction
using Rademacher series on dual BCH codes. Proc. 19th
Annual ACM-SIAM Symposium on Discrete algorithms
(pp. 1–9).
Alon, N. (2003). Problems and results in extremal combinatorics, Part I. Discrete Math, 273, 31–53.
Bennett, J., & Lanning, S. The Netflix Prize. Proceedings
of KDD Cup and Workshop 2007.
Bernstein, S. (1946). The theory of probabilities. Moscow:
Gastehizdat Publishing House.
Cormode, G., & Muthukrishnan, M. (2004). An improved
data stream summary: The count-min sketch and its applications. LATIN: Latin American Symposium on Theoretical Informatics.

Dasgupta, A., Sarlos, T., & Kumar, R. (2010). A Sparse
Johnson Lindenstrauss Transform. Submitted.
Ganchev, K., & Dredze, M. (2008). Small statistical models by random feature mixing. Workshop on Mobile Language Processing, Annual Meeting of the Association for
Computational Linguistics.
Gionis, A., Indyk, P., & Motwani, R. (1999). Similarity
search in high dimensions via hashing. Proceedings of
the 25th VLDB Conference (pp. 518–529). Edinburgh,
Scotland: Morgan Kaufmann.
Langford, J., Li, L., & Strehl, A. (2007).
Vowpal wabbit online learning project (Technical Report).
http://hunch.net/?p=309.
Ledoux, M. (2001). The concentration of measure phenomenon. Providence, RI: AMS.
Li, P., Church, K., & Hastie, T. (2007). Conditional random
sampling: A sketch-based sampling technique for sparse
data. In B. Schölkopf, J. Platt and T. Hoffman (Eds.),
Advances in neural information processing systems 19,
873–880. Cambridge, MA: MIT Press.
Liberty, E., Ailon, N., & Singer, A. (2008). Dense fast random projections and lean Walsh transforms. Proc. 12th
International Workshop on Randomization and Approximation Techniques in Computer Science (pp. 512–522).
Matousek, J. (2008).
On variants of the Johnson–
Lindenstrauss lemma. Random Structures and Algorithms, 33, 142–156.
Rahimi, A., & Recht, B. (2008). Random features for largescale kernel machines. In J. Platt, D. Koller, Y. Singer
and S. Roweis (Eds.), Advances in neural information
processing systems 20. Cambridge, MA: MIT Press.
Rahimi, A., & Recht, B. (2009). Randomized kitchen
sinks. In L. Bottou, Y. Bengio, D. Schuurmans and
D. Koller (Eds.), Advances in neural information processing systems 21. Cambridge, MA: MIT Press.
Shi, Q., Petterson, J., Dror, G., Langford, J., Smola, A.,
Strehl, A., & Vishwanathan, V. (2009). Hash kernels.
AISTATS 12.
Weinberger, K., Dasgupta, A., Attenberg, J., Langford, J.,
& Smola, A. (2009). Feature hashing for large scale multitask learning. 26th International Conference on Machine Learning (p. 140).

Feature Hashing for Large Scale Multitask Learning

A. Mean and Variance
Proof [Lemma 2] To compute the expectation we expand
X
ξ(i)ξ(j)xi x′j δh(i),h(j) .
(10)
hx, x′ iφ =
i,j

Since Eφ [hx, x′ iφ ] = Eh [Eξ [hx, x′ iφ ]], taking expectations over ξ we see that only the terms i = j have nonzero
value, which shows the first claim. For the variance we
2
compute Eφ [hx, x′ iφ ]. Expanding this, we get:
X
2
hx, x′ iφ =
ξ(i)ξ(j)ξ(k)ξ(l)xi x′j xk x′l δh(i),h(j) δh(k),h(l) .

the proof follows that of Lemma 6 (Dasgupta et al., 2010).
We still outline the proof because of some parameter values
being different.
Lemma 8 Let m be the size of the hash function range and
. If x is such that kxk2 = 1 and
let η = √ 1
2 m log(m/δ)
Pd
kxk∞ ≤ η, then define σ∗2 = maxi j=1 x2j δih(j) where i
ranges over all hash-buckets. We have that with probability
1 − δ,
σ∗2 ≤

2
m

i,j,k,l

Proof We outline the proof-steps. Since the buckst
ets have identical distribution, we look
P only at 2the 1
Eξ [ξ(i)ξ(j)ξ(k)ξ(l)] = δij δkl + [1 − δijkl ](δik δjl + δil δjk ). bucket, i.e. at i = 1 and bound
j:h(j)=1 xj . De
1
2
fine Xj = xj δ1h(j) − m . Then Eh [Xj ] = 0 and
Passing the expectation over ξ through the sum, this allows

x4
x2 η 2
1
us to break down the expansion of the variance into two
− m12 ≤ mj ≤ jm using kxk∞ ≤
Eh [Xj2 ] = x4j m
2
P
P
terms.
η. Thus, j Eh [Xj2 ] ≤ ηm . Also note that j Xj =
X
X
P


1
2
2
2
Eφ [hx, x′ iφ ] =
xi x′i xk x′k +
x2i x′j Eh δh(i),h(j)
j:h(j)=1 xj − m . Plugging this into the Bernstein’s inequality, equation 5, we have that
i,k
i6=j
X




X
+
xi x′i xj x′j Eh δh(i),h(j)
1
1/2m2
X
>
Pr[
]
≤
exp
−
j
i6=j
m
η 2 /m + η 2 /3m


j
1 X 2 ′2 X
3
2
xi xj +
= hx, x′ i + 
xi x′i xj x′j 
= exp(−
) ≤ exp(− log(m/δ)) ≤ δ/m
m
8mη 2
i6=j
i6=j
This expression can be simplified by noting that:



1
for i 6= j. Using the fact
by noting that Eh δh(i),h(j) = m
2
′ 2
that σ = Eφ [hx, x iφ ]−Eφ [hx, x′ iφ ]2 proves the claim.

B. Concentration of Measure
We use the concentration result derived by Liberty, Ailon
and Singer in (Liberty et al., 2008). Liberty et al. create a Johnson-Lindenstrauss random projection matrix by
combining a carefully constructed deterministic matrix A
with random diagonal matrices. For completeness we
restate the relevant lemma. Let i range over the hashbuckets. Let m = c log(1/δ)/ǫ2 for a large enough constant c. For a given vector x, define the diagonal matrix
Dx as (Dx )jj = xj . For any matrix A ∈ ℜm×d , define
kxkA ≡ maxy:kyk2 =1 kADx yk2 .
Lemma 2 (Liberty et al., 2008). For any columnnormalized matrix A, vector x with kxk2 = 1 and an
i.i.d. random ±1 diagonal matrix Ds , the following holds:
∀x, if kxkA ≤ √ ǫ
then, Pr[|kADs xk2 −1| > ǫ] ≤
6

log(1/δ)

δ.

We also need the following form of a weighted balls and
bins inequality – the statement of the Lemma, as well as

By taking union bound over all the m buckets, we get the
above result.

Proof [Theorem 3] Given the function φ = (h, r), define
the matrix A as Aij = δih(j) and Ds as (Ds )jj = rj . Let
x be as specified, i.e. kxk2 = 1 and kxk∞ ≤ η. Note that
kxkφ = kADs xk2 . Let y ∈ ℜd be such that kyk2 = 1.
Thus
2

m
d
X
X

yj δih(j) xj 
kADx yk22 =
i=1

≤
≤

j=1

d
d
m X
X
X
x2j δih(j) )
yj2 δih(j) )(
(
i=1 j=1

m
X

d
X

(

i=1 j=1

j=1

yj2 δih(j) )σ∗2 ≤ σ∗2 .

by applying the Cauchy-Schwartz inequality, and using the
definition of σ∗ . Thus, kxkA = maxy:kyk2 =1 kADx yk2 ≤
√
σ∗ ≤ 2m−1/2 . If m ≥ 72
ǫ2 log(1/δ), we have that
, which satisfies the conditions of
kxkA ≤ √ ǫ
6

log(1/δ)

Lemma 2 from (Liberty et al., 2008). Thus applying the
above result from Lemma 2 (Liberty et al., 2008) to x, and

Feature Hashing for Large Scale Multitask Learning

using Lemma 8, we have that Pr[|kADs xk2 − 1| ≥ ǫ] ≤ δ
and hence

bedding dimensionality. The details of this contradiction are best presented through (Weinberger et al.,
2009, Corollary 5) as follows.

Pr[|kxk2φ − 1| ≥ ǫ] ≤ δ

Set m = 128 and δ = 1/2 and consider the vertices of the n-simplex in ℜn+1 , i.e., x1 = (1, 0, ..., 0),
x2 = (0, 1, 0, ..., 0), . . . . Let P ∈ ℜ(n+1)c×(n+1)
be the naive, replication based preconditioner, with
replication parameter c = 512 log2 n as defined in
Section 2 of our submission or (Weinberger et al.,
2009, Section 3.2). Therefore for all pairs
i 6= j
√
we have that ||P xi√− P xj ||∞ = 1/ c and that
||P xi − P xj ||2 = 2. Hence we can apply (Weinberger et al., 2009, Corollary
5) to the set of vec√
1/(32 log n); then the
tors P xi with η = 1/ 2c = q

by taking union over the two error probabilities of Lemma
2 and Lemma 8, we have the result.

C. Inner Product
2

Proof [Corollary 4] We have that 2 hx, x′ iφ = kxkφ +
2
2
kx′ kφ − kx − x′ kφ . Taking expectations, we have the standard inner product inequality. Thus,

claimed approximation error is

|2 hx, x′ iφ − 2 hx, x′ i | ≤ | kxk2φ − kxk2 |
2

2

2

1
1
8 + 16

2

+ | kx′ kφ − kx′ k | + | kx − x′ kφ − kx − x′ k |

Using union bound, with probability 1 − 3δ, each of the
terms above is bounded using Theorem 3. Thus, putting
the bounds together, we have that, with probability 1 − 3δ,
2

2

2

|2 hφu (x), φu (x)i − 2 hx, xi | ≤ ǫ(kxk + kx′ k + kx − x′ k )

D. Refutation of the Previous Incorrect Proof
There were a few bugs in the previous version of the paper (Weinberger et al., 2009). We now detail each of them
and illustrate why it was an error. The current result shows
that the using hashing we can create a projection matrix
that can preserve distances to a factor of (1 ± ǫ) for vectors
with a bounded kxk∞ /kxk2 ratio. The constraint on input
vectors can be circumvented by multiple hashing, as outlined in Section 3.2, but that would require hashing O( ǫ12 )
times. Recent work (Dasgupta et al., 2010) suggests that
better theoretical bounds can be shown for this construction. We thank Tamas Sarlos and Ravi Kumar for the following writeup on the errors and for suggestion the new
proof in Appendix B.
1. The statement of the main theorem in Weinberger et
al. (Weinberger et al., 2009, Theorem 3) is false as
it contradicts the lower bound of Alon (Alon, 2003).
The flaw lies in the probability of error in (Weinberger
et al., 2009,
Theorem 3), which was claimed to be
√
ǫ
exp(− 4η ). This error can be made arbitrarily small
without increasing the embedding dimensionality m
∞
but by decreasing η = ||x||
||x||2 , which in turn can be
achieved by preprocessing the input vectors x. However, this contradicts Alon’s lower bound on the em-

2 n
2
2
m +64η log 2δ

=

1
4.

≤ If Corollary 5 were true, then it would follow that with probability at least 1/2, the linear transformation A = φ · P : ℜn+1 → ℜm distorts the pairwise distances of the above n + 1 vectors by at most
a 1 ± 1/4 multiplicative factor. On the other hand,
the lower bound of Alon shows that any such transformation A must map to Ω(log n) dimensions; see the
remarks following Theorem 9.3 in (Alon, 2003) and
set ǫ = 1/4 there. This clearly contradicts m = 128
above.
2. The proof of the Theorem 3 contained a fatal, unfixable error. Recall that δij denotes the usual Kronecker symbol, and h and h′ are hash functions. Weinberger et al. make the following observation after
equation (13) of their proof on page 8 in Appendix
B.
P P
“First note that i j δh(j)i + δh′ (j)i is at
most 2t, where t = |{j : h(j) 6= h′ (j)}|.”

The quoted observation is false.
Let d denote the diP P
mension
of
the
input.
Then,
P P
Pi j δh(j)i + δh′ (j)i =
′
(
δ
+
δ
)
=
h (j)i
j
i h(j)i
j 2 = 2d, independent
of the choice of the hash function. Note that t played
a crucial role in the proof of (Weinberger et al., 2009)
relating the Euclidean approximation error of the dimensionality reduction to Talagrand’s convex distance
defined over the set of hash functions. Albeit the error
is elementary, we do not see how to rectify its consequences in (Weinberger et al., 2009) even if the claim
were of the right form.

3. The proof of Theorem 3 in (Weinberger et al., 2009)
also contains a minor and fixable error. To see this,
consider the sentence towards the end of the proof
Theorem 3 in (Weinberger et al., 2009) where 0 <
ǫ < 1 and β = β(x) ≥ 1.
p
“Noting that √ s2
=
( β2 + ǫ −
β)/4||x||∞ ≥ ǫ/4||x||∞ , ...”

Feature Hashing for Large Scale Multitask Learning

p
Here the authors wrongly assumepthat β 2 + ǫ−β ≥
√
√
ǫ holds, whereas the truth is β 2 + ǫ − β ≤ ǫ
always.
Observe that this glitch is easy to fix locally, however
this change is minor and the modified claim would
still be
√ false. Since for all 0 ≤ y ≤ 1 we have
that p1 + y ≥ 1 + y/3, from β ≥ 1 it follows
that β 2 + ǫ − β ≥ ǫ/3. Plugging the latter estimate into the “proof” of Theorem 3 would result in a
modified
claim where the original probability of error,
√
ǫ
ǫ
exp(− 4η ), is replaced with exp(− 12η
). Updating
the numeric constants in the first section of this note
would show that the new claim still contradicts Alon’s
lower bound. To justify observe that counter example
is based on a constant ǫ and the modified claim would
still lack the necessary Ω(log n) dependency in its target dimensionality.

