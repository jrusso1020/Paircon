Fast Flux Discriminant for Large-Scale Sparse Nonlinear Classiﬁcation
Wenlin Chen
Department of Computer Science and Engineering Washington University in St. Louis, USA

Yixin Chen
Department of Computer Science and Engineering Washington University in St. Louis, USA

Kilian Q. Weinberger
Department of Computer Science and Engineering Washington University in St. Louis, USA

wenlinchen@wustl.edu

chen@cse.wustl.edu

kilian@wustl.edu

ABSTRACT
In this paper, we propose a novel supervised learning method, Fast Flux Discriminant (FFD), for large-scale nonlinear classiﬁcation. Compared with other existing methods, FFD has unmatched advantages, as it attains the eﬃciency and interpretability of linear models as well as the accuracy of nonlinear models. It is also sparse and naturally handles mixed data types. It works by decomposing the kernel density estimation in the entire feature space into selected lowdimensional subspaces. Since there are many possible subspaces, we propose a submodular optimization framework for subspace selection. The selected subspace predictions are then transformed to new features on which a linear model can be learned. Besides, since the transformed features naturally expect non-negative weights, we only require smooth optimization even with the 1 regularization. Unlike other nonlinear models such as kernel methods, the FFD model is interpretable as it gives importance weights on the original features. Its training and testing are also much faster than traditional kernel models. We carry out extensive empirical studies on real-world datasets and show that the proposed model achieves state-of-the-art classiﬁcation results with sparsity, interpretability, and exceptional scalability. Our model can be learned in minutes on datasets with millions of samples, for which most existing nonlinear methods will be prohibitively expensive in space and time.

Keywords
classiﬁcation, interpretability, sparsity, submodularity

1.

INTRODUCTION

Categories and Subject Descriptors
H.2.8 [Database Management]: Database ApplicationsData Mining; J.3 [Computer Applications]: Life and Medical Sciences

General Terms
Theory
Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for proﬁt or commercial advantage and that copies bear this notice and the full citation on the ﬁrst page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a fee. Request permissions from permissions@acm.org. KDD’14, August 24–27, 2014, New York, NY, USA. Copyright 2014 ACM 978-1-4503-2956-9/14/08 ...$15.00. http://dx.doi.org/10.1145/2623330.2623627.

In supervised classiﬁcation, there are several potentially competing needs. For example in biomedical applications, classiﬁers often need to be feature-sparse, in order to identify leading risk factors for prevention and intervention of critical medical conditions. In addition, the training sets can be very large, thus requiring good scalability, but the classiﬁer should also be expressive enough to model nonlinear feature interaction. Finally, and possibly most importantly, the classiﬁer must also achieve high accuracy. These requirements are by no means speciﬁc to biomedical applications. In fact, they are representative for many machine learning application domains. Although several methods excel at various aspects, to date none manages to capture all of them. Linear classiﬁers [33] cover many of these needs: they can be highly scalable [8], learn weights that are naturally interpretable and, if paired with 1 regularization, can also be feature-sparse [7, 29]. Because of these strengths, they are a common choice for machine learning practitioners. However, linear classiﬁers fall short on at least two of the desired requirements: they cannot learn nonlinear decision boundaries, which inherently limits their accuracy on diﬃcult or lower-dimensional datasets. Further, they cannot discover the relevance of features that are beneﬁcial only through nonlinear interactions with each other. Nonlinear classiﬁers can model such feature interactions and are not limited by linear decision boundaries, but they typically suﬀer from diﬀerent limitations. For example, deep neural nets [12] are highly nonlinear and scalable, but do not naturally incorporate feature sparsity and the decisions are hard to interpret. Similarly, tree ensembles, such as Random Forests [4], share the same weaknesses. The kernel trick [26] is a popular method to extend linear classiﬁers to learn nonlinear decision boundaries, but it also removes their natural interpretability and scalability. To get the best out of both nonlinear methods (nonlinear separability) and linear methods (high eﬃciency), a recent trend in data mining and machine learning is to replace heavy nonlinear machineries with simpler linear ones, and to achieve high accuracy by introducing certain nonlinearity in feature mapping. That is, they map the original input data x ∈ RD to a feature vector φ(x) ∈ RM and then learn a linear hyperplane wT φ(x), w ∈ RM [17, 22, 24, 30]. A linear classiﬁer, trained on φ(x) ∈ RM instead of the “raw” fea-

tures x ∈ RD , can learn nonlinear decision boundaries in the original input space while maintaining its high scalability. Unfortunately, however, this approach does not also maintain its interpretability and feature-sparseness. The classiﬁer weights can no longer be interpreted, which drastically limits the usefulness of this approach for many applications tied to the discovery of feature importance. As our ﬁrst contribution, we propose a novel algorithm, which we refer to as Fast Flux Discriminant (FFD). FFD is designed to combine all the strengths of linear and nonlinear supervised learning. It maintains the scalability, featuresparsity and interpretability of linear classiﬁers, yet can learn non-linear decision boundaries, discover pairwise feature interactions and it matches the high accuracy of state-of-theart nonlinear models. At its core, FFD is based on kernel density estimation (KDE) [3]. The ultimate goal of (discriminative) supervised learning is to estimate the conditional label distribution p(y |x), for a label y of an input x ∈ RD . If unlimited labeled data were available, this distribution could be estimated directly with KDE. In practice, however, such a na¨ ıve approach does often not work. The curse of dimensionality [3] makes the data requirements of KDE grow exponentially with the data dimensionality, thus quickly exceeding any realistic limitations, if the data is suﬃciently high dimensional. However, if the dimensionality is low, KDE is very eﬀective. Chen et al. [6] make use of KDE as a feature transformation. They point out that if features do not interact with each other, the conditional label distribution can be dep(y =1|[x]d ) (y =1|x) = w0 + D composed as log pp d=1 wd log p(y =−1|[x]d ) , (y =−1|x) where [x]d denotes the dth dimension of x and the weights wd are estimated from the data.1 Similar to Rahimi and Recht [24], this approach learns an explicit feature transformation that enables linear classiﬁers to learn non-linear decision boundaries. Unfortunately, it cannot discover nonlinear feature interactions. In this paper we follow this insight but relax the restriction that features cannot interact with each others. Instead, we assume that features can interact, but their interactions are limited to r D features. Let A denote a set or “bag” of features, with |A| ≤ r, and let [x]A denote the shortened input vector x with only those features in A. We assume that r is small enough, so that p(y |[x]A ) can still be computed fast and accurately via KDE. FFD learns a new representation x → Φ(x), where each dimension of Φ(x) corresponds to the conditional label distribution p(y |[x]A ) for some feature bag A. A linear classiﬁer learned on the data Φ(x) can learn nonlinear decision boundaries and its weights indicate which feature “bags” are most important. If in addition the classiﬁer is regularized to be sparse, we can identify which feature bags are in fact suﬃcient to make accurate predictions. Because KDE is highly non-linear and approximates the true conditional distribution, FFD reliably learns the within-bag feature interactions. One immediate challenge with this setup is the exponentially growing number, D , of possible sets A. How can we r identify which such sets of features to include in our representation? Our second contribution is to formulate this as This approximation is exact for wd = 1 if the features are label conditionally independent, which is also often referred to as the Na¨ ıve Bayes assumption [3].
1

a tractable optimization problem. We propose a novel optimization framework which maximizes the similarity coverage and minimizes redundancy of the selected feature set. Moreover, the optimization formulation contains cardinality penalty for sparsity and interpretability. We formulate this selection problem as a combinatorial optimization with a submodular objective. Previous work [9] proves that for this category of problems, there exists a 1/3-approximation bound in the worst case. To further promote feature sparsity of the FFD model, we also employ 1 regularization. A disadvantage of typical 1 regularization is that it is not diﬀerentiable everywhere and requires non-smooth optimization techniques such as subgradient descent. However, since the KDE features in FFD model conditional label distribution, their weights are naturally expected to be non-negative. Based on this key insight, we add non-negativity constraints to the training objective and make it a smooth optimization problem even with 1 regularization. This enables us to employ fast smooth optimization algorithms. Finally, we carry out extensive experiments on real-world datasets and show that the proposed FFD model achieves state-of-the-art classiﬁcation results with exceptional scalability. FFD can be learned in minutes on datasets with millions of samples, for which other nonlinear methods will be prohibitively expensive in space and time. FFD also demonstrates interpretability and results in very sparse models. This paper is organized as follows. In Section 2, we present the notations and preliminaries. We describe the proposed FFD model in Section 3. We discuss related work in Section 4 and present experimental results in Section 5. Section 6 gives conclusions.

2.

PRELIMINARIES

In this section, we introduce the notations and review the density-based logistic regression (DLR) model [6], which is highly related to the proposed model. Assume we are given a dataset D = {xi , yi }, i = 1, · · · , N , xi ∈ RD where D is the number of attributes2 , and the label yi ∈ {−1, 1}. Let the input vector be xi = ([xi ]1 , · · · , [xi ]D ). D can be further partitioned into two datasets D1 and D−1 , which include all the data points whose labels are y = 1 and y = −1, respectively. In the training phase, the DLR model ﬁrst maps each training sample to a new feature space in a dimension-wise manner, i.e. x → Φ(x) where Φ(x) = (φ1 (x), φ2 (x), · · · , φD (x)) . Similar to logistic regression, DLR models the conditional probability of y given a sample x by a sigmoid function on the transformed features. 1 (1) p(y = 1|x) = 1 + exp (− (wΦ(x))) where the parameter w can be learned via maximum likelihood estimation or equivalently the empirical risk minimization with logistic loss: minimize
w 2

1 N

N

1 + e−yi (wΦ(xi )) + λ w
i=1

2

(2)

For simplicity, here we only discuss datasets with numerical features. The proposed method also applies to datasets with categorical and mixed features.

If we use the original attributes without feature mapping, i.e. φd (x) = [x]d for d = 1, · · · , D, Eq. (1) is the original LR. Unlike LR, DLR introduces a nonlinear feature mapping based on the following rationale. First, Eq. (1) can be rewritten as: p(y = 1|x) (3) wΦ(x) = ln p(y = −1|x) Assuming conditional independence of the attributes given the class label y , it can be shown that [6] ln p(y = 1|x) = w0 + p(y = −1|x)
D

3.

FAST FLUX DISCRIMINANT (FFD)

ln
d=1

p(y = 1|[x]d ) p(y = −1|[x]d )

(4)

In this section, we propose our FFD model. Like DLR, FFD also performs a feature mapping based on density estimation and then learns a linear machine after the feature mapping. However, FFD is signiﬁcantly diﬀerent from DLR and oﬀers a few salient advantages. It does not assume conditional independence and is able to capture the correlation between features. Also, it preserves the interpretability and explicitly promotes sparsity of the model. Moreover, the learning process of FFD is far more eﬃcient than DLR, leveraging on the fast computing of low-dimensional density estimation via histogram estimation. In summary, the main steps of FFD include the following. 1. Subspace feature mapping, which generates features based on non-parametric kernel density estimation. 2. Submodular subspace selection, which selects subspace features based on submodular optimization. 3. Model training, which learns a sparse and interpretable linear machine with smooth 1 regularization. All the above steps are designed to be highly eﬃcient and capable of scaling to large data. Below, we discuss the main components of FFD before putting them together.

(y =1) . Comparing (3) with (4) where w0 = (D − 1) ln pp (y =−1) and setting w = 1, we can naturally derive the following feature transformation used by DLR. For each dimension d, the DLR feature mapping is:

φd (x) = ln

p(y = 1|[x]d ) , p(y = −1|[x]d )

(5)

which is a logit transformation on the conditional probability of y given a single feature [x]d . In order to compute the features φd (x) in (5), DLR estimates p(y |[x]d ) by treating categorial and numerical attributes in diﬀerent ways. • If [x]d is a categorical attribute, p(y = 1|[x]d ) is estimated by counting the proportion of samples with label y = 1 among all the samples whose dth attribute is [x]d . Let D[x]d be the set of of samples in D whose dth attribute equals to [x]d . The DLR estimate is φd (x) = ln |D1 D[x]d | . |D−1 D[x]d | (6)

3.1

Subspace feature mapping

• If [x]d is a numerical attribute, then DLR calculates φd (x) by kernel density estimation (KDE) [3]. The DLR estimate is φd (x) = ln
i∈D1 [xi ]d ) exp(− ([x]d − ) h2
d 2

i∈D−1

[xi ]d ) exp(− ([x]d − ) h2
d

2

,

(7)

where hd is a parameter called the kernel bandwidth. In the training phase, DLR ﬁrst computes the feature mapping and then calls a standard LR package to learn w. In the testing phase, given a testing sample x, the DLR model ﬁrst transforms it to Φ(x) via KDE or counting depending on the feature type. The conditional probability of y given x is then calculated by Eq. (1). Though DLR oﬀers good interpretability as it assigns a weight to each original dimension, it has some serious drawbacks. 1) DLR has high training and testing complexity. Although DLR is more eﬃcient in its training time, its feature computation is still expensive. For a dataset with N samples and D dimensions, DLR requires O(DN 2 ) time for training and O(DN ) time for testing one single sample. Such a testing cost is the same as kernel SVM, making it too expensive for applications where extensive testings are required. 2) DLR generates dense vectors and does not oﬀer sparsity. 3) DLR assumes conditional independence of each dimension give the class label, which is often violated in practice and may suﬀer from high correlation between dimensions.

This step generates features that can eﬀectively model the conditional probability p(y |x), which enables the nonlinear separability of the model. It is based on non-parametric density estimation which does not make any parametric assumption of the data distribution and is particular suitable for large data since it can make full use of all the data samples. Here, we ﬁrst describe the histogram-based density estimation in general for the full feature space, which is unrealistic due to the curse of dimensionality. But the same idea can be applied to and is very eﬃcient for low-dimensional subspaces. We then combine the predictions from all subspaces via a linear model and generate nonlinear classiﬁcation decision boundary. First, each dimension is divided into equal-length bins. Let bd be the number of bins for the dth dimension. If [x]d is categorical, bd is always the number of categories for this feature. If [x]d is numerical, bd is a parameter we need to set. In the training phase, given the training dataset D = {xi , yi }, i = 1, · · · , N , we assign each training sample to the corresponding bin. If [xi ]d is a categorical feature, B ([xi ]d ), the bin index for dimension d is the category index of [xi ]d . For a numerical feature, suppose the bins of the dth dimension start at startd = min {[xk ]d }
k=1..N

and end at endd = max {[xk ]d }.
k=1..N

The bin length ld is given by: ld = endd − startd bd [xi ]d − startd ld (8)

Let B ([xi ]d ) be the bin index for [xi ]d . We have that B ([xi ]d ) = (9)

1

p(y = 1|B)

p(y = 1|B)

0.5

[x]1
0 1 2 3 [x]1 4 5
[x]2

[x]1

4 6 2 1 3

[x]2

Figure 2: Kernel smoothing for a 1-D histogram. The height of each bin is the proportion of y = 1 in each bin based on counting. The purple dots are the new p(y = 1|B) for each bin after kernel smoothing.

Figure 1: Histogram estimation for a 2-D subspace. Left: a snapshot of a 2-D grid. Right: The proportion of y = 1 in each grid cell based on counting. Each data sample xi corresponds to a grid cell3 (a vector of bin indices): B (xi ) = (B ([xi ]1 ), · · · , B ([xi ]D )) . After assigning each training sample to the corresponding grid cell, a naive histogram-based density method would estimate the the probability of p(y |x) by counting the proportion of samples with diﬀerent labels in grid cell B (x). This naive histogram-based density estimation is eﬃcient and does not make any assumption on the distribution of the underlying data. However, if the number of training samples is not enough, this estimation would suﬀer from huge bias and variance. In addition, the number of grid cells grows exponentially with the number of dimensions, leading to the curse of dimensionality. As a result, this simple histogram method is not practical. To overcome this problem, instead of directly modeling p(y |x) by density estimation for the whole space, FFD expresses p(y |x) by a number of density estimation for low dimensional subspaces. Each subspace contains a small number (less than r) of features. In essence, we assume that features can interact with each other, but their interactions are limited to r D features. We assume that r is small enough, so that the density estimation for r-dimensional subspaces can still be computed fast. For example, Figure 1 shows the histogram-based density estimation for a 2-dimensional subspace. This subspace is discretized into a grid as shown on the left subﬁgure. The proportion of training samples with y = 1, i.e. p(y = 1|B), is then computed for each grid cell by simple counting as shown on the right subﬁgure. To combine the density estimations from all subspaces, we convert the result from each subspace to a new feature and then apply a linear model on these new features. Speciﬁcally, FFD learns a new representation x → Φ(x), where Φ(x) = (φ1 (x), · · · , φM (x)) is a vector of M subspace features. For each m = 1, · · · , M , FFD uses the following feature φm (x) = ln
3

where Am ⊂ {1, · · · , D}, |Am | ≤ r, is a subset of feature dimensions and [x]Am = ([x]d∈Am ) are x’s values in the dimensions included in Am . Following the design of logistic regression, FFD models the following probability: p(y = 1|x) = 1 + exp − 1
M m=1

. wm φm (x)

(11)

3.2

Kernel smoothing for histogram

FFD estimates p(y = 1|[x]Am ) via histogram-based density estimation. Since the cardinality |Am | ≤ r where r D, it avoids the curse of dimensionality. For relatively small datasets, the histogram estimation for the subspace speciﬁed by Am is still unstable. First, if the length of bins is too small, there would be few data samples in each bin, resulting in inaccurate estimation. Second, the histogram estimation could be non-smooth for neighboring bins. To address these issues, we propose to use a bin kernel smoothing technique, which allows the bins to aﬀect each other according to their mutual kernel. Suppose B = (B1 , · · · , B|Am | ) is a grid cell in the subspace speciﬁed by the dimensions in Am and denote GAm as the set of all the grid cells in this subspace. We have the following smoothed estimate for grid cell B p(y |B) =
B ∈GAm

nB (y )K bin (B, B ) NB K bin (B, B )

(12)

B ∈GAm

where nB (y ) is the the number of training samples with label y in B , and NB is the total number of training samples in B . The kernel between two grid cells B and B is a Guassian kernel given by K bin (B, B ) = exp −
d∈Am 2 (Bd − Bd )2 ld 2 2hd

(13)

where hd > 0 is a parameter called the bandwidth of the kernel density function. A popular rule of thumb [27] for deciding the value of hd is as follow:
−1/5 h∗ , d = 1.06σd N

p(y = 1|[x]Am ) , p(y = −1|[x]Am )

(14)

(10)

In this paper, the meanings of “bin” and “grid cell” are interchangeable. We often refer to “bin” in the context of a single dimension and “grid cell” otherwise

where σd is the standard deviation of the training samples on dth dimension. Figure 2 illustrates the kernel smoothing for a 1-dimensional histogram. As we can observe, p(y = 1|B) in the third bin is originally very low due to the lack of data.

However, after kernel smoothing, this value gets higher and the overall histogram becomes smoother. In essence, the proposed bin kernel smoothing is an approximation of KDE by discretizing each dimension into bins and treating all samples in the bin as located at the center of the bin. Not surprisingly, we can show that the approximation error approaches zero as the discretization is ﬁne enough. Proposition 1. As bd → ∞, the conditional probability estimated by (12) approaches the result by the NadarayaWatson estimator [3] p ˆ(y = 1|[x]Am ) =
i∈D1 KAm (x, xi ) N i=1 KAm (x, xi )

term minimizes the pair-wise correlations within S to reduce the redundancy and relieve the problem of highly correlated features and co-linearity. 3) The third term maximizes the overall accuracy of histogram estimation of the selected subspaces. 4) The fourth term minimizes the cardinality of S for sparsity. The maximization of (17) is a NP-hard problem. However, we show that (17) is a submodular maximization problem and good approximation bound can be achieved. We ﬁrst introduce the concept of submodular set functions. Deﬁnition 1. [10] Suppose U is the ground set, a set function f : 2U → R is submodular if it satisﬁes the property of diminishing return: for every A, B ∈ U , A ⊆ B , and every e ∈ U − B , we have that f (A ∪ e) − f (A) ≥ f (B ∪ e) − f (B ). If equality always holds in (18), f is modular. It has been shown that maximizing a submodular function without any constraints can achieve a 1/3-approximation bound using a deterministic local search (DLS) algorithm [9, 13]. That is, 1 fobj (Sg ) ≥ fobj (S ∗ ), 3 where fobj is the objective function in (17), Sg is the solution by the DLS algorithm, and S ∗ is the optimal solution. Note that this lower bound only occurs in the worst case. In practice, the performance is typically much better. Now we prove the submodularity of (17). Theorem 1. The objective function in (17) is submodular if ci,j ≥ 0, ∀i, j ∈ U . Proof. Let fc (S ) =
i∈S j ∈U −S

(15)

where D1 is the set of training samples with label y = 1 and KAm (x1 , x2 ) is a Guassian kernel function on variables speciﬁed by Am , namely, KAm (x1 , x2 ) = exp −
d∈Am

(18)

([x1 ]d − [x2 ]d )2 2h2 d

.

(16)

The size of memory required to store all histogram inforM mation is O where bAm = d∈Am bd is the m=1 bAm total number of grid cells required for the subspace speciﬁed by Am . Since |Am | is always very small (e.g. less than 3), the memory cost will not be large. One advantage of FFD is that the size of the model does not increase as the training dataset gets larger. This is diﬀerent from other popular non-parametric models such as RBF-SVM and KNN. For example, in RBF-SVM all the support vectors should be stored. As the training set gets larger, the number of support vectors will also increase. In addition, in the testing phase, the kernel matrix between support vectors and testing samples needs to be computed, resulting in O(Nt Ns ) running time where Nt is the size of the testing data and Ns is the number of support vectors. In contrast, FFD has a linear test time O(Nt ), since for a given testing sample FFD only needs to retrieve the value stored in the histogram in order to compute φm .

ci,j − α
i,j ∈S,i=j

ci,j .

(19)

3.3

Submodular subspace selection

Let U be the ground set containing all subspace candidates, i.e. all Am ⊂ {1, · · · , D} such that |Am | ≤ r. The r D cardinality of U is k=1 k . With so many candidates, one key challenge is to determine which subspaces in U to choose from. Here we propose a combinatorial optimization framework to address this problem. Suppose S ⊆ U is the set of subspaces we select, we propose to ﬁnd S such that maximize
S i∈S j ∈U −S

It has been shown that fc (S ) is submodular if ci,j ≥ 0, ∀i, j ∈ U [20]. Moreover, it is easy to verify that β i∈S ai is a modular function and that −µ|S |2 is submodular function according to Deﬁnition 1. Since submodularity is preserved under non-negative linear combination of submodular functions [10], we see that the the objective function in (17) is submodular. In practice, we ﬁnd that most ci,j are non-negative, since each φm is an indicator of the label y and they are not likely to have negative correlation. For completeness, we have the following lemma to help guarantee the submodularity of (17). Lemma 1. Let γ = − min {mini,j {ci,j }, 0}, then fc (S ) − γ (1 + α)|S |2 is submodular where fc (S ) is deﬁned in (19). Proof. Let eS be the |U | × 1 indicator vector of set S where U is the ground set, and eS (i) = 1 if Ai ∈ S and 0 otherwise 4 (so eU is a vector whose elements are all 1). Let C be the correlation matrix of all elements in U where its element (i, j ) is ci,j . We rewrite the function in matrix form as follows fc (S ) = eS C (eU − eS ) − αeS (C − I )eS = eS CeU + αeS IeS − (α + 1)eS CeS = eS CeU + α|S | − (α + 1)eS CeS
4

ci,j − α
i,j ∈S,i=j

ci,j + β
i∈S

ai − µ|S |2

(17) where ci,j is the Pearson correlation between φi and φj based on Ai and Aj , respectively. ai is the training accuracy of the subspace estimation for GAi , which can be computed efﬁciently by simply checking the number of mislabeled samples in all grid cells of GAi . (α, β, µ) are all non-negative hyper-parameters. The four components in (17) correspond to four diﬀerent goals, respectively. 1) The ﬁrst term, which is a cut function [10], maximizes the similarity coverage of the set U so that set S is a good representative of U . 2) The second

(20)

eS (i) is the i

th

element in eS

Suppose E is a |U | × |U | matrix with all elements being 1. It is easy to show that |S |2 = eS EeS . Thus, we have that fc (S ) − γ (1 + α)|S |2 =eS CeU + α|S | − (α + 1)(eS CeS + γeS EeS ) =eS CeU + α|S | − (α + 1)eS (C + γE )eS Now we deﬁne C + = C + γE. (22) (21)

According to the deﬁnition of γ , we have that γ ≥ 0 and elements in C + are all non-negative. Thus, −(α + 1)eS (C + γE )eS is submodular due to the submodularity of negative quadratic function [2]. In addition, we can see that eS CeU + α|S | is modular. Thus, fc (S ) − γ (1 + α)|S |2 is submodular. Theorem 2. When µ ≥ γ , the objective function in (17) is submodular and the DLS algorithm has a 1/3-approximation bound in the worst case. Proof. According to Lemma 1, (17) can be rewritten as c+ i,j − α
i∈S j ∈U −S i,j ∈S,i=j

Algorithm 1 The learning algorithm for FFD 1: for m = 1 to M do Histogram estimation 2: Build grid GAm . 3: for i = 1 to N do 4: Assign xi to the grid cell indexed by (9) 5: end for 6: for B ∈ GAm do 7: Compute p(y |B) by (12) 8: end for 9: end for 10: for i = 1 to N do Computing φm (xi ) 11: for m = 1 to M do 12: Compute φm (xi ) by (10) 13: end for 14: end for 15: Select subspaces by solving (17) using the DLS algorithm 16: Learn w by solving (25)

non-negative, we have that w 1 = M m=1 wm . The learning formulation with 1 regularization becomes: minimize
w

c+ i,j + β
i∈S

ai − (µ − γ )|S |2 , (23)

1 N

N

M

1 + e−yi (wΦ(xi )) + λ
i=1 m=1

wm

(25)

where c+ i, j are elements in C + deﬁned in (22). Since c+ i,j ≥ 0, we see that (23) has the same form as deﬁned in Theorem 1 if µ − γ ≥ 0. Thus, it is submodular and has a 1/3approximation bound [9]. In practice, we can ﬁrst compute all the ci,j and γ , and then choose a µ value such that µ ≥ γ . Therefore, we can always guarantee the submodularity and optimization bound.

subject to

w≥0

3.4

Sparse learning algorithm

Since the dimensionality of subspaces should be relatively small to avoid the curse of dimensionality, in this paper we have a restriction that |Am | ≤ 2. So there are M = O(D(D +1)/2) potential φm (x) including 1-dimensional and 2-dimensional subspaces. After all those φm (x) are computed by smoothed histogram estimation and ﬁltered by submodular subspace selection, we need to learn the weight vector w = (w1 , · · · , wM )5 in (11). We require strong sparsity on w, which is not satisﬁed by the learning framework in (2). One simple alternative is to replace the 2 regularization with 1 regularization [11] which promotes sparsity. However, the FFD model has a nice structure and can oﬀer an even better solution. Let us rewrite (10) as φm (x) = ln p(y = 1|[x]Am ) = g (p(y = 1|[x]Am )) (24) 1 − p(y = 1|[x]Am )

Compared with other 1 norm method, the 1 norm in our framework is diﬀerentiable for all feasible w. Such a smooth optimization problem with simple bound constraints can be eﬃciently solved by gradient-descent solvers. Using (25), FFD also enforces more sparsity than traditional 1 regularization. To see that, assume that the gradient of a positive wm is negative. When doing gradient descent on it, wm will tend to decrease its value. But due to the non-negative constraint, it cannot go below 0 and will thus end up at 0, which leads to even more sparse solution than 1 regularization. The overall learning algorithm for FFD is shown in Algorithm 1.

3.5

Discussions

We make a few further comments about FFD. Cross validation. Before executing the complete algorithm of FFD as stated in Algorithm 1, all the hyperparameters should be pre-speciﬁed including λ in (25) and (α, β, µ) in (17). Experts can set these hyper-parameters by good intuition. For non-experts, a typical way to tune them is utilizing a k-fold cross-validation where grid search is performed on all hyper parameters to minimize the validation error. However, this brute-force algorithm has a high computational cost. In addition, it does not make use of the validation errors during the grid search. As a better solution,we use a recent Bayesian optimization technique [28] to tune the hyper-parameters in order to globally minimize the validation error. Speciﬁcally, the validation error is modeled as a sample from a Gaussian Process (GP). Each time, we sample the hyper-parameters (λ, α, β, µ) which minimize the expectation of its validation error under the assumption of GP. Then, Algorithm 1 is run on this hyper-parameter sample to evaluate its actual cross-validation error. This sample with its validation error

z where g (z ) = ln 1− is a logit function. We can observe z that φm (x) is an increasing function of p(y = 1|[x]Am ). In addition, φm (x) ≥ 0 if p(y = 1|[x]Am ) ≥ 0.5 and less than 0 otherwise. Given the monotonic relation between p(y = 1|x) and φm (x) in (11), the weight wm on φm (x) is supposed to be non-negative under the assumption that p(y = 1|[x]Am ) estimated by histogram is a weak learner. Given that w is 5 Now M is the number of φm after submodular subspace selection.

are then incorporated in the previous GP and forms a new GP. This process keeps running until a maximum iteration limit is reached. The best hyper-parameters are the one that have the minimum cross-validation error among all the samples. It has been shown that this Bayesian optimization method for cross validation largely outperforms normal grid search [28]. Usefulness of submodular subspace selection. Though 1 regularization encourages sparsity, the performance of linear methods with 1 regularization (including logistic regression) suﬀers if the input variables are highly correlated or even co-linear [11,14]. Thus, before training FFD by solving (25), it is necessary and important to do subset selection on all φm in order to reduce their correlation. Interpretability. Similar to LR, FFD can provide probability of its prediction in addition to the predicted label. However, in LR model the weights on diﬀerent features may not be directly comparable. For example, the measurement of blood pressure has a vastly diﬀerent scale than that of height, and their weights are not comparable. In contrast, the weights w in FFD do not suﬀer from this problem because all φm are on the same scale as they model conditional probabilities. In addition, each φm (x) is an indicator of p(y = 1|[x]Am ) because they have a monotonic relationship as shown in (10). With the sparsity of FFD, we can also identify which feature bags Am are in fact suﬃcient to make accurate predictions based on the weights. Since kernel density estimation for the subspaces is highly nonlinear and approximates the true conditional distribution, FFD reliably learns the feature interactions.

Table 1: Comparison of the characteristics of diﬀerent classiﬁers. LR SVM-rbf DLR RKS FFD Interpretable Yes No Yes No Yes Eﬃcient Yes No No Yes Yes Nonlinear No Yes Yes Yes Yes Sparse Yes No No No Yes

mation, random projection, and hashing are all deﬁned in a diﬀerent space than that of the original features. As a result, these models do not provide a weight for each original feature dimension and cannot oﬀer a clear notion of interpretability. Moreover, all these works except for [18] do not explicitly support sparsity.

5.

EXPERIMENTAL RESULTS

In this section, we conduct extensive experiments to evaluate the proposed FFD model. We evaluate three versions of FFD. • FFD-1: FFD with only 1-dimensional subspaces, i.e. |Am | ≤ 1, and without submodular subspace selection. • FFD-2: FFD with 1-dimensional and 2-dimensional subspaces, i.e. |Am | ≤ 2, and without submodular subspace selection. • FFD-sfo: FFD-2 with submodular optimization for subspace selection. In FFD-2 and FFD-sfo, for φm involving two dimensions, we picks the top 3D out of D(D − 1)/2 such φm ’s according to their accuracies for histogram estimation, where D is the dimensionality of the training samples. For all the three methods, we set the number of bins for numerical features to 50, i.e. bd = 50. For submodular maximization in (17), we use the sfo toolbox developed by Andreas Krause [16]. To solve the sparse learning problem in (25), we use the minConf TMP function6 . This function is superior at optimizing smooth objective functions subject to bound constraints, which is exactly our case. Baseline methods. We also consider four other methods for comparison. 1) Logistic regression with 1 regularization (LR) [11], implemented by Mark Schmidt [25]. 2) Support vector machines with the RBF kernel (SVM-rbf). We use the LibSVM library [5]. 3) Density-based Logistic Regression (DLR) [6], a linear classiﬁer with nonlinear feature mapping based on the naive Bayes assumption. 4) Random Kitchen Sink (RKS) [24], a linear classiﬁer with nonlinear feature mapping that approximates the RBF kernel. A comparison of the characteristics of these models is given in Table 1. We can see that FFD is the only model that can support all of the desirable properties including interpretability, nonlinearity, eﬃciency, and sparsity. Cross validation. The hyper-parameters in all methods are tuned via cross validation. The cross validations are performed by Bayesian optimization which has been proved to be far more eﬃcient and accurate than a simple grid search [28]. For the RKS model, we also cross validate all
6 Available at http://www.di.ens.fr/~mschmidt/Software/minConf

4.

RELATED WORK

Our FFD model is related to density-based logistic regression (DLR) [6] which transforms the original raw features to a new feature representation by KDE and then trains a logistic regression model on the new feature vectors. However, it does not promote sparsity and is not capable of handling feature interaction. In addition, compared to DLR, the feature transformation in FFD allows much faster computation, reducing the training time from O(DN 2 ) to O(DN ) and the testing time from O(DN ) to O(D). In general, FFD is related to recent works on learning linear models with explicit nonlinear feature transformations. For example, random kitchen sinks (RKS) [24] transforms each data x into a ﬁnite-dimensional vector φ(x) ∈ RM to approximate the RBF-kernel function for any two inputs x and y in such way that φ(x)T φ(y) ≈ K (x, y ), where K (x, y) is the RBF kernel function. This allows highly scalable linear classiﬁers in the transformed space to learn approximately the same decision boundaries as SVM with a RBF kernel in the original input space. The recent fastfood algorithm [17] further speeds up RKS using matrix approximation techniques and reduces the time and space complexities. Other feature mapping techniques include those based on random projection [1,15,18,23], polynomial approximation [21], and hashing [19, 32] Existing feature mapping techniques, when combined with linear classiﬁers, can achieve both nonlinear separability and higher scalability of linear classiﬁers. However, they cannot take advantage of the interpretability of linear classiﬁers. The feature mapping techniques such as Fourier transfor-

!

!

"#!)

"#!)

%#+

%#+

%#')

%#')

'#$

'#$

'#")

 '#")  '#*  %#))  "#"  "#&)  !#)  !  "#$  %#&  %#"  '#(

'#*

%#))

"#"

"#&)

!#) ! "#$ %#& %#" '#( ' '#( %#" %#& "#$ !

'

'#(

%#"

%#&

"#$

!

Figure 3: The decision boundary of FFD-1 on a toy example. Left: FFD-1 with 20 bins for each dimension. Right: FFD-1 with 100 bins for each dimension. types of features including random Fourier features and random binning features. Visualization of a toy example. We create a nonlinearly separable dataset to visualize the classiﬁcation ability of FFD method and the eﬀect of using diﬀerent number of bins, as shown in Figure 3. We can observe that the FFD1 can perfectly separate the two classes while other linear methods cannot. We also see that, as the number of bins increases, the decision boundary gets smoother. Comprehensive evaluation. Table 2 shows a comprehensive comparison of all methods on various datasets. All these datasets are publicly available at the UCI repository7 or the LibSVM website8 . The datasets are sorted by the number of samples in the datasets. The experiments are run on an oﬀ-the-shelve desktop with two 8-core Intel(R) Xeon(R) processors of 2.67 GHz and 128GB of RAM. The implementations of all methods are in or through the interface of MATLABT M . In order for SVM-rbf to run as fast as possible, we set the cache size of LibSVM to 10GB which is suﬃciently large for all the tested datasets. From Table 2, we can observe the following facts. In terms of accuracy, the performance of FFD methods is fairly strong in general. Datasets including checkboard, banana, mnist38 and cod-rna are well-known for its high non-linearity, which can be told by the poor performance of LR on these datasets. However, both FFD-2 and FFDsfo perform almost as good as SVM-rbf and RKS, which demonstrates their superior nonlinear classiﬁcation ability. And for datasets including splice and Adult, FFD methods largely outperforms all the other methods. In terms of running time, we can see that FFD models are very eﬃcient in general, which is fairly comparable with and sometimes even better than the linear machines LR and RKS. For example, the Adult dataset has 14 features, among which 8 are categorical. Models such as LR, SVMrbf and RKS should ﬁrst convert the categorical features to numerical features before training. The most popular method, as recommended in [31], is using k binary numerical features to represent an k-category feature. For example, (red,blue,green) can be represented by (1,0,0), (0,1,0) https://archive.ics.uci.edu/ml/datasets.html http://www.csie.ntu.edu.tw/~cjlin/libsvmtools/ datasets/binary.html
8 7

and (0,0,1). We observe that the original 14 features increase to 104 features at the end, which adds to the burden of training. In contrast, our FFD models naturally handle categorical features since each category is a bin in its dimension and no kernel smoothing is needed, leading to superior time eﬃciency. We also see that FFD models are much more eﬃcient than nonlinear models such as SVM-rbf and DLR. For the cod-rna dataset with 0.27 million samples, it takes FFD models less than 1 second while SVM-rbf spends over 10 minutes and DLR cannot ﬁnish. The improvement is even more salient on the kddcup99 dataset which contains almost 5 million samples. We make kddcup99 a binary classiﬁed dataset by setting class 6 to a positive class and other classes to a negative class, since class 6 contains 57% of the samples. It takes FFD models less than one minute while it is prohibitively large for both SVM-rbf and DLR. However, though FFD-sfo generally has good accuracy and eﬃciency, we also point out that the cost of submodular optimization is sensitive to the dimensionality of the datasets, and using submodular subspace selection may not be the most sensible for image datasets such as mnist38. However, even for the mnist38 dataset, FFD-sfo is much faster than SVM-rbf and DLR, while FFD-1 and FFD-2 are extremely fast. In terms of practical usability, FFD models give interpretability and sparsity, while other nonlinear models including SVM-rbf and RKS do not. In summary, FFD is a clear winner considering all the aspects. Cases of highly correlated features. As stated in Section 3, linear methods including models with 1 regularization become more unstable and less accurate when highly correlated features or co-linearity exist. Although FFD methods are capable of classifying nonlinear datasets, they are linear models on φm and thus may also suﬀer from this issue. In this case, FFD-sfo is better than FFD-2 since it rules out highly correlated φm by maximizing the submodular objective function in (17). This eﬀect has been partially reﬂected in Table 2. To demonstrate the advantage of FFD-sfo over FFD-2 in a more observable way, we conduct another experiment in the feature selection context. First, we make a new splice data set by duplicating each feature, which makes them colinear. Then, we run FFD-2 and FFD-sfo on both the original and new datasets. For reference, we also run the LR and Lasso [11] models which are state-of-the-art feature selection methods. For FFD methods, one feature is considered selected if it is used by any φm whose wm = 0. Figure 4 shows the curves about accuracy versus number of selected features. First, we observe that FFD methods is much better than LR and Lasso since FFD oﬀers nonlinear separability. Second, although FFD-2 and FFD-sfo have comparable performance on the original dataset, FFD-sfo is way better than FFD-2 on the new dataset, demonstrating the ability of FFD-sfo in addressing the issue of highly correlated or co-linear features. Real-world clinical prediction. In addition to evaluation on public benchmark datasets, we also test FFD models on a real-world clinical application. This is a collaboration with Barnes-Jewish Hospital, one of the largest hospitals in the US. The task is to predict potential ICU transfers for hospitalized patients based on 34 vital signs. The data col-

Table 2: Performance of various methods on various datasets. Note that the FFD models have the additional advantages of interpretability and sparsity, which are not found in SVM-rbf and RKS. “N/A” means unﬁnished in 2 hours or memory overﬂow. Dataset breast splice checkboard banana musk mnist38 magic04 Adult cod-rna kddcup99 N 683 1000 2000 5300 6598 11982 14226 30162 271617 4898431 D 9 60 2 2 166 784 10 14 8 41 Performance accuracy(%) time(sec) accuracy(%) time(sec) accuracy(%) time(sec) accuracy(%) time(sec) accuracy(%) time(sec) accuracy(%) time(sec) accuracy(%) time(sec) accuracy(%) time(sec) accuracy(%) time(sec) accuracy runtime(sec) LR 96.63 0.0164 80.70 0.0144 49.70 0.0143 56.70 0.0126 94.33 1.2882 96.77 0.9187 79.50 0.2639 84.71 6.8223 75.08 0.785 99.99 179.2541 SVM-rbf 96.05 0.0165 87.20 0.2468 93.95 0.1454 90.45 0.6449 90.69 58.6402 99.11 230.1897 86.38 20.145 80.43 492.7818 91.75 629.759 N/A N/A DLR 97.36 0.0574 92.00 0.4069 51.00 0.0589 71.89 0.2354 95.21 23.1885 97.09 1621 82.59 21.6976 85.41 81.8001 N/A N/A N/A N/A RKS 97.07 0.0573 90.10 0.0679 92.50 0.8763 89.57 0.5021 96.42 0.7666 97.28 0.4323 84.57 1.6225 83.96 3.8515 92.29 5.7484 99.92 41.3827 FFD-1 96.34 0.0278 91.60 0.0835 51.25 0.0188 71.74 0.0326 96.88 1.0141 96.32 2.0696 81.40 0.3211 85.40 0.4057 77.34 0.6583 99.99 46.2968 FFD-2 97.51 0.4242 94.60 1.235 92.20 0.0434 89.72 0.0516 95.06 4.1618 98.69 1.0952 82.21 0.188 85.31 3.1718 89.53 1.0074 99.99 50.0306 FFD-sfo 97.07 0.5779 94.50 2.2159 92.30 0.07 89.91 0.0298 94.71 25.139 98.98 122.419 84.98 0.4033 85.42 1.1399 89.73 0.7651 99.99 54.0227

1 0.9 Accuracy 0.8 0.7 0.6 0.5 0
LR (L1) Lasso FFD−2 FFD−sfo

1 0.9 Accuracy 0.8 0.7 0.6 0.5 0
LR (L1) Lasso FFD−2 FFD−sfo

0.2 0.4 0.6 0.8 Proportion of Selected Features

1

0.2 0.4 0.6 0.8 Proportion of Selected Features

1

Figure 4: Accuracy vs. proportion of selected features. Left: The original splice dataset; Right: The new splice dataset with co-linear features. lection process can be found in [6]. On this dataset, FFD-sfo and FFD-2 have 95.37% and 94.59% accuracy, respectively. The results outperform the DLR model with a 93.26% accuracy which is found to be better than LR and SVM [6]. Moreover, FFD is the only model that can oﬀer sparsity and interpretability. This is vitally important in clinical practice since healthcare personnel can be informed of the most important risk factors and take proper actions for prevention and intervention. feature mapping which captures nonlinear feature interactions. FFD addresses the curse of dimensionality by decomposing the kernel density estimation in the original feature space into low-dimensional subspaces. We have also proposed a submodular optimization framework to select subspaces and to address the problem of highly correlated features and collinearity. Moreover, FFD attains feature sparsity using 1 regularization. A nice feature of FFD is that its density-based features naturally have non-negative weights and hence allows for smooth optimization, which is not previously possible for 1 regularization. Empirical results have shown that FFD delivers similar accuracy as state-of-the-art nonlinear classiﬁers, but with sparsity, interpretability, and much better scalability. To the best of our knowledge, this is the ﬁrst classiﬁer that possesses all these merits. Given its unprecedented combination of advantages, we believe FFD will become a popular general-purpose classiﬁcation model

6.

CONCLUSIONS

Many applications in the big data era ﬁnd existing classiﬁers inadequate. They often require not only high accuracy but also high eﬃciency, sparsity, and interpretability. To date no classiﬁer, linear or nonlinear, excel at all these aspects. We have presented a novel Fast Flux Discriminant (FFD) model which delivers all these desirable properties. FFD learns a linear discriminant on top of a non-parametric

for a large scope of real-world applications such as biomedical prediction.

7.

ACKNOWLEDGMENTS

WC and YC are supported in part by the CNS-1017701, CCF-1215302, and IIS-1343896 grants from the National Science Foundation of the United States, a Microsoft Research New Faculty Fellowship, a Washington University URSA grant, and a Barnes-Jewish Hospital Foundation grant. KQW is supported by NSF grants 1149882, 1137211.

8.

REFERENCES

[1] D. Achlioptas. Database-friendly random projections: Johnson-Lindenstrauss with binary coins. Journal of Computer and System Science, 66:671–687, 2003. [2] F. Bach. Learning with submodular functions: A convex optimization perspective. Foundations and Trends in Machine Learning, 2013. [3] C. M. Bishop. Pattern Recognition and Machine Learning. Springer-Verlag New York, Inc., Secaucus, NJ, USA, 2006. [4] L. Breiman. Random forests. Machine Learning, 45(1):5–32, 2001. [5] C.-C. Chang and C.-J. Lin. LIBSVM: A library for support vector machines. ACM Transactions on Intelligent Systems and Technology, 2:27:1–27:27, 2011. [6] W. Chen, Y. Chen, Y. Mao, and B. Guo. Density-based logistic regression. In Proceedings of the 19th ACM SIGKDD, KDD ’13, pages 140–148, New York, NY, USA, 2013. ACM. [7] B. Efron, T. Hastie, I. Johnstone, and R. Tibshirani. Least angle regression. The Annals of statistics, 32(2):407–499, 2004. [8] R.-E. Fan, K.-W. Chang, C.-J. Hsieh, X.-R. Wang, and C.-J. Lin. Liblinear: A library for large linear classiﬁcation. The Journal of Machine Learning Research, 9:1871–1874, 2008. [9] U. Feige and V. S. Mirrokni. Maximizing non-monotone submodular functions. In In Proceedings of 48th Annual IEEE Symposium on Foundations of Computer Science (FOCS, page 2007, 2007. [10] S. Fujishige. Submodular Functions and Optimization: Second Edition. Annals of Discrete Mathematics. Elsevier Science, 2005. [11] T. Hastie, R. Tibshirani, and J. H. Friedman. The Elements of Statistical Learning. Springer, 2009. [12] G. E. Hinton, S. Osindero, and Y.-W. Teh. A fast learning algorithm for deep belief nets. Neural computation, 18(7):1527–1554, 2006. [13] R. Iyer, S. Jegelka, and J. A. Bilmes. Fast semidiﬀerential-based submodular function optimization. In International Conference on Machine Learning (ICML), Atlanta, Georgia, 2013. [14] G. James, T. Hastie, D. Witten, and R. Tibshirani. An Introduction to Statistical Learning: With Applications in R. Springer, 2013. [15] P. Kar and H. Karnick. Random feature maps for dot product kernels. In Proc. AISTATS, 2012.

[16] A. Krause. Sfo: A toolbox for submodular function optimization. The Journal of Machine Learning Research, 11:1141–1144, 2010. [17] Q. Le, T. Sarlos, and A. Smola. Fastfood - computing hilbert space expansions in loglinear time. In Proceedings of the 30th International Conference on Machine Learning, volume 28, pages 244–252, May 2013. [18] P. Li, T. J. Hastie, and K. W. Church. Very sparse random preojections. In Proc. SIGKDD, pages 287–296, 2006. [19] P. Li and A. Konig. b-bit minwise hasing. In Proc. WWW, 2010. [20] H. Lin and J. Bilmes. Multi-document summarization via budgeted maximization of submodular functions. ACL-HLT ’10, pages 912–920, Stroudsburg, PA, USA, 2010. Association for Computational Linguistics. [21] K. Lin and M. Chen. Eﬃcient kernel approximation for large-scale support vector machine classiﬁcation. In Proc. SIGKDD, 2011. [22] O. Pele, B. Taskar, A. Globerson, and M. Werman. The pairwise piecewise-linear embedding for eﬃcient non-linear classiﬁcation. In Proceedings of The 30th International Conference on Machine Learning, pages 205–213, 2013. [23] N. Pham and R. Pagh. Fast and scalable polynomial kernels via explicit feature maps. In Proc. SIGKDD, 2013. [24] A. Rahimi and B. Recht. Random features for large-scale kernel machines. In J. Platt, D. Koller, Y. Singer, and S. Roweis, editors, Advances in Neural Information Processing Systems 20. MIT Press, Cambridge, MA, 2008. [25] M. Schmidt, G. Fung, and R. Rosales. Fast optimization methods for l1 regularization: A comparative study and two new approaches. In ECML, volume 4701, pages 286–297. 2007. [26] B. Sch¨ olkopf and A. J. Smola. Learning with kernels. The MIT Press, 2002. [27] B. W. Silverman and P. J. Green. Density Estimation for Statistics and Data Analysis. Chapman and Hall, 1986. [28] J. Snoek, H. Larochelle, and R. Adams. Practical bayesian optimization of machine learning algorithms. In Advances in Neural Information Processing Systems 25, pages 2960–2968. 2012. [29] R. Tibshirani. Regression shrinkage and selection via the lasso. Journal of the Royal Statistical Society. Series B (Methodological), pages 267–288, 1996. [30] A. Vedaldi and A. Zisserman. Eﬃcient additive kernels via explicit feature maps. Pattern Analysis and Machine Intelligence, IEEE Transactions on, 34(3):480–492, 2012. [31] C. wei Hsu, C. chung Chang, and C. jen Lin. A practical guide to support vector classiﬁcation, 2010. [32] K. Weinberger, A. Dasgupta, J. Langford, A. Smola, and J. Attenberg. Feature hashing for large scale multitask learning. In Proc. ICML, 2009. [33] G. Yuan, C. Ho, and C. Lin. Recent advances of large-scale linear classiﬁcation. Proceedings of the IEEE, 100:2584–2603, 2012.

