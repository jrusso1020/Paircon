A Reduction of the Elastic Net to Support Vector Machines with an Application to GPU Computing

arXiv:1409.1976v1 [stat.ML] 6 Sep 2014

Quan Zhou* zhouq10@mails.tsinghua.edu.cn Shiji Song* shijis@mail.tsinghua.edu.cn Kilian Q. Weinberger † kilian@wustl.edu Tsinghua University* Beijing 100084, China

Wenlin Chen† wenlinchen@wustl.edu Jacob R. Gardner† gardner.jake@wustl.edu Yixin Chen † ychen25@wustl.edu

Washington University in St. Louis† 1 Brookings Drive, MO 63130, USA

Abstract
The past years have witnessed many dedicated open-source projects that built and maintain implementations of Support Vector Machines (SVM), parallelized for GPU, multi-core CPUs and distributed systems. Up to this point, no comparable effort has been made to parallelize the Elastic Net, despite its popularity in many high impact applications, including genetics, neuroscience and systems biology. The ﬁrst contribution in this paper is of theoretical nature. We establish a tight link between two seemingly different algorithms and prove that Elastic Net regression can be reduced to SVM with squared hinge loss classiﬁcation. Our second contribution is to derive a practical algorithm based on this reduction. The reduction enables us to utilize prior efforts in speeding up and parallelizing SVMs to obtain a highly optimized and parallel solver for the Elastic Net and Lasso. With a simple wrapper, consisting of only 11 lines of MATLABTM code, we obtain an Elastic Net implementation that naturally utilizes GPU and multi-core CPUs. We demonstrate on twelve real world data sets, that our algorithm yields identical results as the popular (and highly optimized) glmnet implementation but is one or several orders of magnitude faster.

1 Introduction
The Elastic Net [28] and Lasso as a special case [12] are arguably two of the most celebrated and widely used feature selection algorithms of the past decade. The increase in data set sizes has led to a rise in the demand for fast implementations of popular machine learning techniques. For example in fMRI classiﬁcation [22] one can easily obtain data sets with p > 1, 000, 000 voxels. Similarly in genetics [11] genome-wide predictions often have millions of features. Meanwhile, the increased availability of GPU processing and multi-core CPUs has provided a natural means to scale up algorithms through parallelization. However, some algorithms are easier to parallelize than others. For example, deep (convolutional) neural networks can naturally take advantage of multiple GPUs [18]; support vector machines (SVM) have been ported to GPUs [8, 26], multi-core CPUs [7, 26] and even distributed systems [6, 21]. Although not originally parallelized, liblinear [9] utilizes clever dual coordinate ascent updates to drastically speed up linear SVMs. 1

Despite the growing trend, feature selection algorithms have yet to embrace parallel computing platforms in a similar fashion. One of the most popular parallel implementations of Lasso may be Shotgun [4], which however in our experiments does often not outperform the (admittedly highly optimized) single-core Elastic Net implementation glmnet by Friedman [10]. This imbalance of parallelization may be in part due to the fact that parallelizing algorithms is hard to do. For example, the GT-SVM implementation of kernel-SVM for GPUs uses handwritten CUDA kernels [8] to truly utilize the computing power of modern graphics cards. This is not only highly labor intensive, it also requires constant maintenance as hardware and software standards progress. In this paper we introduce a different approach to parallelize the Elastic Net, and Lasso as a special case. Instead of proposing a new hand designed parallel implementation of the core algorithm, we take inspiration from recent work on machine learning reductions [15, 19] and we reduce the Elastic Net to the squared hinge-loss SVM (without a bias term). We show that this reduction is exact and extremely efﬁcient in practice. The resulting algorithm, which we refer to as Support Vector Elastic Net (SVEN), naturally takes advantage of the vast existing work on parallel SVMs, immediately providing highly efﬁcient Elastic Net and Lasso implementations on GPUs, multi-core CPUs and distributed systems [6, 8, 9, 21, 26]. We make three main contributions: 1. we prove a theoretical result and derive the non-trivial equivalence between the Elastic Net and SVM with squared hinge loss; 2. we turn this equivalence relationship into a practical algorithm, SVEN, which can solve any Elastic Net or Lasso problem with out-of-the-box (squared hinge-loss) SVM solvers. 3. we evaluate SVEN on twelve real world data sets (eight in the p ≫ n and four in the n ≫ p setting) and show that SVEN is by far the fastest Elastic Net solver to date—outperforming even the most efﬁcient existing implementation by an order of magnitude across almost all benchmark data sets.

2 Notation and Background
Throughout this paper we type vectors in bold (x), scalars in regular (C or b), matrices in capital bold (X). Speciﬁc entries in vectors or matrices are scalars and follow the corresponding convention, i.e. the ith dimension of vector x is xi . In contrast, depending on the context, x(i) refers to the ith column in matrix X and xi refers to the transpose of its ith row. 1 is a column vector of all 1. In the remainder of this section we brieﬂy review the Elastic Net and SVM. Elastic Net. In the regression scenario we are provided with a data set {(xi , yi )}n i=1 , where each xi ∈ Rp and the labels are real valued, i.e. yi ∈ R. Let y = (y1 , . . . , yn )⊤ be the response vector and X ∈ Rn×p be the design matrix where the (transposed) ith row of X is xi . As in [28], we assume throughout that the response vector is centered and all features are normalized. The Elastic Net [28] learns a (sparse) linear model to predict yi from xi by minimizing the squared loss with L2-regularization and an L1-norm constraint,
β ∈Rp

min

Xβ − y

2 2

+ λ2 β

2 2

such that |β|1 ≤ t,

(1)

where β = [β1 , . . . , βp ]⊤ ∈ Rp denotes the weight vector, λ2 ≥ 0 is the L2-regularization constant and t > 0 the L1-norm budget. In the case where λ2 = 0, the Elastic Net reduces to the Lasso [12] as a special case. The L1 constraint encourages the solution to be sparse. The L2 regularization coefﬁcient has several desirables effects: 1. it makes the problem strictly convex and therefore yields a unique solution; 2. if features are highly correlated it assigns non-zero weights to all of them (making the solution more stable); 3. if p ≫ n the optimization does not become unstable for large values of t. SVM with squared hinge loss. In the classiﬁcation setting we are given a training dataset ˆ i ∈ Rd and y ˆi ∈ {+1, −1}. The linear SVM with squared hinge loss opti{(ˆ xi , y ˆi )}m i=1 where x mization problem [25] learns a separating hyperplane, parameterized by a weight vector w ∈ Rd , with the regularized squared hinge loss: min
w

1 w 2

m 2 2

+C
i=1

2 ξi

ˆ i ≥ 1 − ξi ∀i. such that y ˆi w⊤ x

(2)

2

Here, C > 0 denotes the regularization constant. Please note that in this paper we do not include any bias term, i.e. we assume that the separating hyperplane will pass through the origin. This problem is often solved in its dual formulation, which due to strong duality is equivalent to solving (2) directly. Without replicating the derivation [14, 25], we state the dual problem of (2) as:
αi ≥0

ˆα min Z

2 2

+

1 2C

m

m

α2 i
i=1

−2
i=1

αi ,

(3)

ˆ = (ˆ ˆ m ) is a d × m maˆ1 , . . . , y ˆm x where α = (α1 , . . . , αm ) denote the dual variables and Z y1 x th (i) ˆ i multiplied by its corresponding label y trix, of which the i column z consists of input x ˆi , ˆ i . The two formulations (2) and (3) are equivalent and the solutions connect via i.e. z(i) = y ˆi x m ˆi. w = i=1 y ˆi αi x ˆ ⊤Z ˆ , which corresponds to the inner-product matrix of In (3) the data is only accessed through Z ⊤ˆ ˆ ˆj y ˆ⊤ ˆj . In scenarios with d ≫ m, this matrix the input rescaled by the labels, i.e. [Z Z]ij = y ˆi x i x can be pre-computed and cached in a kernel matrix in O(m2 ) memory and O(d) operations, which makes the remaining running time independent of the dimensionality [25]. Historically, the dual formulation is most commonly used to achieve non-linear decision boundaries, with the help of the kernel-trick [25]. In our case, however, we will only need the linear setting and restrict the kernel (inner-product matrix) to be linear, too. Both formulations of the SVM can be solved particularly efﬁciently on modern hardware with Newton’s Method [7, 9], which ofﬂoads the majority of the computation onto matrix operations and therefore can be vectorized and parallelized to achieve near peak computing performance [26]. In this work, as we do not use the standard SVM with linear hinge loss, we refer to the SVM with squared hinge loss simply as SVM.

3 The Reduction of Elastic Net to SVM
In this section, we derive the equivalence between Elastic Net and SVM, and reduce problem (1) to a speciﬁc instance of the SVM optimization problem (3). Reformulation of the Elastic Net. We start with the Elastic Net formulation as stated in (1). First, we divide the objective and the constraint by t and substitute in a rescaled weight vector, β := 1 t β. This step allows us to absorb the constant t entirely into the objective and rewrite (1) as 1 min Xβ − y β t
2

+ λ2 β
2

2 2

s.t. |β |1 ≤ 1.

(4)

To simplify the L1 constraint, we follow [24] and split β into two sets of non-negative variables, representing positive components β+ ≥ 0 and negative components β− ≥ 0, i.e. β = β + − β− . ˆ = [β + ; β − ] ∈ R2p . The Then we stack β + and β − together and form a new weight vector β ≥0 2p ˆ 2 2 βi , and (4) can be rewritten as regularization term β can be expressed as
2 i=1

ˆi ≥0 β

min

ˆ − 1y [X, −X] β t

2

2p

+ λ2
2 i=1

ˆi 2 β

2p

s.t.
i=1

ˆi ≤ 1. β

(5)

p 2p Here the set R2 with all non-negative entries. Please note that, as long ≥0 denotes all vectors in R + − as λ2 = 0, the solution to (5) is unique and satisﬁes that βi = 0 or βi = 0 for all i.

Barring the (uninteresting) case with extremely large t ≫ 0, the L1-norm constraint in (1) will ˆ | = 1. (If t is extremely large, (1) is equivalent to ridge regression [12], always be tight [3], i.e. |β which typically yields completely dense (non-sparse) solutions.) We can incorporate this equality constraint into (5) and obtain min ˆ − 1y [X, −X] β t
2 2p

ˆi ≥0 β

+ λ2
2 i=1

ˆi 2 β

2p

s.t.
i=1

ˆi = 1. β

(6)

3

ˆ = 1, we can expand ˆ = [X, −X] β ˆ − 1 y. As 1⊤ β ˆ = [X ˆ 1 , −X ˆ 2 ] such that Z ˆβ We construct a matrix Z t 1 1 ⊤ˆ ⊤ ⊤ ˆ ˆ ˆ y = y1 β and deﬁne X1 = X − t y1 and X2 = X + t y1 . If we substitute Z into (6) it becomes
2p ˆi ≥0 β

ˆβ ˆ min Z

2 2

+ λ2
i=1

ˆi 2 β

2p

s.t.
i=1

ˆi = 1. β

(7)

ˆ ∗ for (7) by In the remainder of this section we show that one can obtain the optimal solution β ∗ ˆ = α∗ /|α∗ |1 , where α∗ is ˆ,y ˆ such that β carefully constructing a binary classiﬁcation data set X ˆ,y ˆ. the solution for the SVM dual (3) for X Data set construction. We construct a binary classiﬁcation data set with m = 2p samples ˆ = [X ˆ 1, X ˆ 2 ]. Let us denote this set as and d = n features consisting of the columns of X ˆ (i) ∈ Rn and y {(ˆ x(1) , y ˆ1 ), . . . , (ˆ x(2p) , y ˆ2p )}, where each x ˆ1 , . . . , y ˆp = +1 and y ˆp+1 , . . . , y ˆ2p = −1. ˆ ˆ In other words, the columns of X1 are of class +1 and the columns of X2 are of class −1. It is ˆ = [X ˆ 1 , −X ˆ 2 ], as used in (7), we have Z ˆ = (ˆ ˆ m ), ˆ1, . . . , y ˆm x straight-forward to see that for Z y1 x ˆ matching the deﬁnition in (3). In other words, the solution of (3) with Z is the SVM classiﬁer when ˆ,y ˆ. applied to X ˆ Optimal solution. Let α∗ denote the optimal solution of (3), when optimized with this matrix Z 1 and C = 2λ . We will now reshape the SVM optimization problem (3) into the Elastic Net (7) 2 without changing the optimal solution, α∗ (up to scaling). First, knowing the optimal solution to 2p (3), we can add the constraint i=1 αi = |α∗ |1 , which is trivially satisﬁed at the optimum, α∗ , and (3) becomes:
2p αi ≥0 2p 2p

min Zα

2 2

+ λ2
i=1

α2 i −2
i=1

αi .

s.t.
i=1

αi = |α∗ |1 .
2p

(8)

Because of this equality constraint, the last term in the objective function in (8), −2 i=1 αi = −2|α∗ |1 , becomes a constant and can be dropped. Removing this constant term does not affect the solution and leads to the following equivalent optimization:
2p αi ≥0 2p

min Zα

2 2

+ λ2
i=1

α2 i.

s.t.
i=1

αi = |α∗ |1 .

(9)

Note that the only difference between (9) and (7) is the scale of design variables. If we divide1 the ∗ ∗ ˆ objective by |α∗ |2 1 and the constraint by |α |1 and introduce a change of variable, βi = αi /|α |1 we ∗ ˆ = α∗ /|α∗ |1 . obtain exactly (7) and its optimal solution β Implementation details. To highlight the fact that this reduction is not just of theoretical value but highly practical, we summarize it in Algorithm 1 in MATLABTM code.2 We refer to our algorithm as Support Vector Elastic Net (SVEN). As mentioned in the previous section 2, the dual and primal formulations of SVM have different time complexities and we choose the faster one depending on whether 2p > n or vice versa. Line 7 converts the primal variables w to the dual solution α [25]. Many solvers [2, 7, 9, 26] have been developed for the linear SVM problem (2). In practice, it is no problem to ﬁnd an implementation with no bias term. Some implementations we investigate do not use a bias by default (e.g. liblinear [9]) and for others it is trivial to remove [7]. In our experiments we use an SVM implementation based on Chapelle’s original exact linear SVM implementation [7] (which can solve the dual and primal formulation respectively). The resulting algorithm is exact and uses a combination of conjugate gradient (until the number of potential support vectors is sufﬁciently small) and Newton steps. The majority of the computation time is spent in the Newton updates. As pointed out by Tyree et al. [26], the individual Newton steps can be parallelized trivially by using
This is not well deﬁned if |α∗ |1 = 0, which is the degenerate case when the SVM selects no support vectors, α = 0, and which is not meaningful without bias term. 2 For improved readability, some variable names are mathematical symbols and would need to be substituted in clear text (e.g. α should be alpha)
1

4

Algorithm 1 MATLABTM implementation of SVEN. 1: function β = SVEN(X, y, t, λ2 ); 2: [n p] = size(X); 3: Xnew = [bsxfun(@minus, X, y./t); bsxfun(@plus, X, y./t)]’; 4: Ynew = [ones(p,1); -ones(p,1)]; 5: if 2p > n then 6: w = SVMPrimal(Xnew, Ynew, C = 1/(2λ2 )); 7: α = C * max(1-Ynew.*(Xnew*w),0); 8: else 9: α = SVMDual(Xnew, Ynew, C = 1/(2λ2 )); 10: end if 11: β = t * (α(1:p) - α(p+1:2p)) / sum(α);

parallel BLAS libraries (which is the default in MATLABTM ), as it involves almost exclusively matrix operations. We also create a GPU version by casting several key matrices as gpuArray, a MATLABTM internal variable type that ofﬂoads computation onto the GPU.3 Feature selection and Lasso. It is worth considering the algorithmic interpretation of this reˆ i in the SVM data set corresponds to a feature of the original Elastic Net duction. Each input x problem. Support Vectors correspond to features that are selected, i.e. βi = 0. If λ2 → 0 the Elastic Net becomes LASSO [12], which has previously been shown to be equivalent to the hard-margin SVM [15]. It is reassuring to see that our formulation recovers this relationship as a special case, as λ2 → 0 implies that C → ∞, converting (2) into the hard-margin SVM. (In practice, to avoid numerical problems with very large values of C , one can treat this case specially and call a hard-margin SVM implementation in lines 6 and 9 of Algorithm 1.) Time complexity. The construction of the input only requires O(np) operations and the majority of the running time will, in all cases, be spent in the SVM solver. As a result, the running time of our algorithm has great ﬂexibility, and for any dataset with n inputs and p dimensions, we can choose an SVM implementation with a running time that is advantageous for that dataset. Chapelle’s MATLABTM implementation can scale in the worst case either O(n3 ) (primal mode) or O(p3 ) (dual mode) [7].4 In the typical case the running times are known to be much better. Especially for the dual formulation we can in practice achieve a running time much better than O(p3 ), as the worst case assumes that all points are support vectors. In the Elastic Net setting, this would correspond to all features being kept. A more realistic practical running time is on the order of O(min(p, n)2 ), depending on the number of features selected (as regulated by t). SVM implementations with other running times can easily be adapted to our setting, for example [16] would allow training in time O(np) and recent work even suggests solvers with sub-linear time complexity [13] (although the solution might be insufﬁciently exact for our purposes in practice).

4 Related Work
The Elastic Net has been widely deployed in many machine learning applications, but only little effort has been made towards efﬁcient parallelization. The coordinate gradient descent algorithm has become the dominating strategy for the optimization. The state-of-the-art single-core implementation for solving the Elastic Net problem is the glmnet package developed by Friedman [10]. Mostly written in Fortran language, glmnet adopts the coordinate gradient descent strategy and is highly optimized. As far as we know, it is the fastest off-the-shelf solver for the Elastic Net. Due to its inherent sequential nature, the coordinate descent algorithm is extremely hard to parallelize. The Shotgun algorithm proposed by [4] is among the ﬁrst to parallelize coordinate descent for Lasso. This implementation can run on extremely sparse large scale datasets that other software, including glmnet, cannot run on due to memory constraints.
The gpuArray was introduced into MATLABTM in 2013. As it is slightly confusing it is worth re-emphasizing that if the original data has n samples with p dimensions, the constructed SVM problem has 2p samples with n dimensions.
4 3

5

Equivalence of regularization path
0.6

Glmnet

0.6

SVEN (GPU)

Coefﬁcients βi

0.4

0.4

0.2

0.2

0

0

0.2 0

0.5

1

1.5

0.2 0

0.5

1

1.5

L1 budget t

L1 budget t

Figure 1: The regularization paths of glmnet (left) and SVEN (GPU) (right) on the prostate dataset. ∗ Each line corresponds to the value of βi as a function of the L1 budget t. The two algorithms match exactly for all values of t. The L1 LS algorithm proposed by [17] transforms the Lasso to its dual form directly and uses a log-barrier interior point method for optimization. The optimization is based on using the Preconditioned Conjugate Gradient (PCG) method to solve Newton steps which is suitable for sparse large scale compressed sensing problems. On the SVM side, one of the most popular and user-friendly implementations is the libsvm library [5]. However, it is optimized to solve kernel SVM problems using sequential minimal optimization (SMO) [23], which is not efﬁcient for the speciﬁc case of linear SVM. The liblinear library [9] is specially tailored for linear SVMs, including the squared hinge loss version. However, we did ﬁnd that on modern multi-core platforms (with and without GPU acceleration) algorithms that actively seek updates through matrix operations [26] tend to be substantially faster (in both settings, p ≫ n and n ≫ p). Our work is inspired by a recent theoretical contribution, Jaggi 2013 [15], which reveals the close relation between Lasso and hard-margin SVMs. We extend this line of work and prove a non-trivial equivalence between the Elastic Net and the soft-margin SVM and we derive a practical algorithm, which we validate experimentally.

5 Experimental Results and Conclusion
In this section, we conduct extensive experiments to evaluate SVEN on twelve real world data sets. We ﬁrst provide a brief description of the experimental setup and the data sets, then we investigate the two common scenarios p ≫ n and n ≫ p separately. For full replicability of the experiments, our source code and links to data sets are available online at http://anonymized. Experimental Setting. We test our method on GPU and (multi-core) CPU under the names of SVEN (GPU) and SVEN (CPU), respectively. For comparison, we have a single-threaded CPU baseline method: glmnet [10], a popular and highly optimized Elastic Net software package. On multi-cores we evaluate two parallelized Lasso implementations. The Shotgun algorithm by Bradley et al. [4] parallelizes coordinate gradient descent. Finally we also compare against L1 LS, a parallel MATLAB solver (for Lasso) implemented by Kim et al. [17]. All the experiments were performed on an off-the-shelve desktop with two 8-core Intel(R) Xeon(R) processors of 2.67 GHz and 96GB of RAM. The attached NVIDIA GTX TITAN graphics card contains 2688 cores and 6 GB of global memory. Regularization path. On all data sets we compare 40 different settings for λ2 and t. We obtain these by ﬁrst solving for the full solution path with glmnet. The glmnet implementation enforces the L1 budget not as a constraint, but as an L1-regularization penalty with a regularization constant λ1 . We obtain the solution path by slowly decreasing λ = λ1 + λ2 . We sub-sample 40 evenly spaced settings along this path that lead to solutions with distinct number of selected features. If the glmnet solution for a particular parameter setting is β ∗ we obtain t by computing t = |β ∗ |1 . This procedure 6

p>>n datasets
GLI85 [n=85, p=22283] arcene [n=900, p=10000] SMKCAN187 [n=187, p=19993] GLABRA180 [n=180, p=49151]

102
SV EN EN (G (G PU PU ) f ) s ast lo er w er SV EN EN (G (G PU PU ) f ) s ast lo er w er

10

0

101 100 10-1

101 100 10-1

Other alg. runtime (sec)

100 10-1 102

10

-1

SV

SV

SV

10-2 10-2

SV

SV EN EN (G (G PU PU ) f ) s ast lo er w er

101

SV EN EN (G (G PU PU ) f ) s ast lo er w er

10

1

102

10

-1

100

10

1

10-1

100

101

10

-1

10

0

10

1

10-1 103

100

101

102

PEMS [n=440, p=138672]

scene15 [n=544, p=71963]

dorothea [n=800, p=88119]

E2006 [n=3308, p=72812]

SV EN EN (G (G PU PU ) f ) s ast lo er w er

SV EN EN (G (G PU PU ) f ) s ast lo er w er

SV EN EN (G (G PU PU ) f ) s ast lo er w er

10

1

101 100 10-1 10-1

102 101 100

10

1

SV

SV

10

-1

10-1 100 101 102 10-1 100 101 102 100 101 102 103

10-1

100

101

102

SV

SVEN (GPU) runtime (sec)

glmnet Shotgun

Figure 2: Training time comparison of various algorithms in p ≫ n scenarios. Each marker compares an algorithm with SVEN (GPU) on one (out of eight) datasets and one parameter setting. The X,Yaxes denote the running time of SVEN (GPU) and that particular algorithm on the same problem, respectively. All markers are above the diagonal line (except SVEN (CPU) for GLI-85), indicating that SVEN (GPU) is faster than all baselines in all cases.

provides us with 40 parameter pairs (λ2 , t) for each data set on which we compare all algorithms. (For the pure Lasso implementations, shotgun and L1 LS, we set λ2 = 0.) Correctness. Throughout all experiments and all settings of λ2 and t we ﬁnd that glmnet and SVEN obtain identical results up to the tolerance level. To illustrate the equivalence, Figure 1 shows the regularization path of SVEN (GPU) and glmnet on the prostate cancer data used in [28]. As mentioned in the previous paragraph, we obtain the original solution path from glmnet and evaluate SVEN (GPU) on these parameter settings. The data has eight clinical features (e.g. log(cancer volume), log(prostate weight)) and the response is the logarithm of prostate-speciﬁc antigen (lpsa). ∗ Each line in Figure 1 corresponds to the βi value of some feature i = 1, . . . , 8 as a function of the L1 budget t. The graph indicates that the two algorithms lead to exactly matching regularization paths as the budget t increases. Data sets with p ≫ n. The p ≫ n scenario may be the most common application setting for the Elastic Net and Lasso and there is an abundance of real world data sets. We evaluate all methods on the following eight of them: GLI-85, a dataset that screens a large number of diffuse inﬁltrating gliomas through transcriptional proﬁling; SMK-CAN-187, a gene expression dataset from smokers w/o lung cancer; GLA-BRA-180, a dataset concerning analysis of gliomas of different grades; Arcene, a dataset from the NIPS 2003 feature selection contest, whose task is to distinguish cancer versus normal patterns from mass spectrometric data; Dorothea, a sparse dataset from the NIPS 2003 feature selection contest, whose task is to predict which compounds bind to Thrombin.5 Scene15, a scene recognition data set [20, 27] where we use the binary class 6 and 7 for feature selection; PEMS [1], a dataset that describes the occupancy rate, between 0 and 1, of different car lanes of San Francisco bay area freeways. E2006-tﬁdf, a sparse dataset whose task is to predict risk from ﬁnancial reports based on TF-IDF feature representation.6
5 6

We removed features with all-zero values across all inputs. Here, we reduce the training set size by subsampling to match the size of the test set, n = 3308.

7

SV

10

0

10

0

SV EN EN (G (G PU PU ) f ) s ast lo er w er

102

10

2

102

SVEN (CPU) L1_Ls

Other alg. runtime (sec)

n>>p datasets
MITFaces [n=489410, p=361] 102 Yahoo [n=141397, p=519] YMSD [n=463715, p=90] 101 FD [n=400000, p=900] 10
2

(G (G PU PU ) f ) s a st lo er w er

SV EN EN (G (G PU PU ) f ) s a st lo er w er

SV EN EN (G (G PU PU ) f ) s a st lo er w er

102

10

1

101

EN

100

SV

EN

SV
101

100

100 102

SV

SV

100

101

100

101

102

10-1 10-1

SV

100

101

SV

101

EN

EN

SVEN (GPU) runtime (sec)

glmnet Shotgun

SVEN (CPU) L1_Ls

Figure 3: Training time comparison of various algorithms in n ≫ p scenarios. Each marker compares an algorithm with SVEN (GPU) on one (out of four) datasets and one parameter setting. The X,Yaxes denote the running time of SVEN (GPU) and that particular algorithm on the same problem, respectively. All markers are above the diagonal line, as SVEN (GPU) is faster in all cases. Evaluation (p ≫ n). Figure 2 depicts training time comparisons of the three baseline algorithms and SVEN (CPU) on the eight datasets with SVEN (GPU). Each marker corresponds to a comparison of one algorithm and SVEN (GPU) in one particular setting along the regularization path. It’s y-coordinate corresponds to the training time required for the corresponding algorithm and its xcoordinate corresponds to the training time required for SVEN (GPU) with the exact same L1-norm budget and λ2 value. All markers above the diagonals corresponds to runs where SVEN (GPU) is faster, and all markers below the diagonal corresponds to runs where SVEN (GPU) is slower. We observe several general trends: 1. Across all eight data sets SVEN (GPU) always outperforms all baselines. The only markers below the diagonal are from SVEN (CPU) on the GLI-85 data set, which is the smallest and where the transfer time for the GPU is not offset by the gains in more parallel computation. 2. Even SVEN (CPU) outperforms or matches the performance of the fastest baseline across all data sets. 3. As the L1-budget t increases, the training time increase for all algorithms, but much more strongly for the baselines than for SVEN (GPU). This can be observed by the fact that the markers of one color (i.e. one algorithm) follow approximately lines with much steeper slope than the diagonal. Data sets with n ≫ p. For the n ≫ p setting, we evaluate all algorithms on four additional datasets. MITFaces, a facial recognition dataset; the Yahoo learning to rank dataset, a dataset concerning the ranking of webpages in response to a search query; YearPredictionMSD (YMSD), a dataset of songs with the goal to predict the release year of a song from audio features; and FD, another face detection dataset. Evaluation (n ≫ p). A comparison to all methods on all four datasets can be found in Figure 3. The speedups of SVEN (GPU) are even more pronounced in this setting. The training time of SVEN (GPU) is completely dominated by the kernel computation and therefore almost identical for all values of t and λ2 . Consequently all markers follow vertical lines in all plots. The massive speedup of up to two orders of magnitude obtained by SVEN (GPU) over the baseline methods squashes all markers at the very left most part of the plot. glmnet failed to complete the FD dataset due to memory constraints and therefore we evaluated on the λ2 and t values along the solution path from the other face recognition data set, MITFaces. As in the p ≫ n case, all solutions returned by both versions of SVEN match those of glmnet exactly. 5.1 Discussion The use of algorithmic reduction to obtain parallelization and improved scalability has several highly compelling advantages: 1. no new learning algorithm has to be implemented and optimized by hand (besides the small transformation code); 2. the burden of code maintenance reduces to the single highly optimized (SVM) algorithm; 3. the implementation is very reliable from the start as almost the entire execution time is spent in a well established and tested implementation; 4. and ﬁnally, target algorithm may lend itself much more naturally to parallelization. In our case, the squared hinge8

(G (G PU PU ) f ) s a st lo er w er
102

loss SVM formulation can be solved almost entirely with large matrix operations, which are already parallelized (and maintained) by high-performance experts through BLAS libraries (e.g. CUBLAS for NVIDIA GPUs http://tinyurl.com/cublas.). We hope that this paper will beneﬁt the community in at least two ways: Practitioners will obtain a new stable and blazingly fast implementation of Elastic Net and Lasso; and machine learning researchers might become inspired to identify and derive different algorithmic reductions to facilitate similar performance improvements with other learning algorithms. Acknowledgements. QZ and SS are supported by Key Technologies Program of China grant 2012BAF01B03, Research Fund for the Doctoral Program of Higher Education 20130002130010, 20120002110035 and NSFC grant 61273233. KQW, JRG, YC, and WC are supported by NIH grant U01 1U01NS073457-01 and NSF grants 1149882, 1137211, CNS-1017701, CCF-1215302, IIS-1343896. Computations were performed via the Washington University Center for High Performance Computing, partially through grant NCRR 1S10RR022984-01A1. The authors thank Martin Jaggi for clarifying discussions and suggestions.

References
[1] K. Bache and M. Lichman. UCI machine learning repository, 2013. [2] L. Bottou. Large-scale machine learning with stochastic gradient descent. In Proceedings of COMPSTAT’2010, pages 177–186. Springer, 2010. [3] S. Boyd and L. Vandenberghe. Convex optimization. Cambridge university press, 2004. [4] J. Bradley, A. Kyrola, D. Bickson, and C. Guestrin. Parallel coordinate descent for l1-regularized loss minimization. In ICML, pages 321–328, 2011. [5] C. Chang and C. Lin. Libsvm: a library for support vector machines. ACM Transactions on Intelligent Systems and Technology (TIST), 2(3):27, 2011. [6] E. Chang, K. Zhu, H. Wang, H. Bai, J. Li, Z Qiu, and H Cui. Psvm: Parallelizing support vector machines on distributed computers. In NIPS, pages 257–264, 2007. [7] O. Chapelle. Training a support vector machine in the primal. Neural Computation, 19(5):1155–1178, 2007. [8] A. Cotter, N. Srebro, and J. Keshet. A gpu-tailored approach for training kernelized svms. In SIGKDD, pages 805–813, 2011. [9] R. Fan, K. Chang, C. Hsieh, X. Wang, and C. Lin. Liblinear: A library for large linear classiﬁcation. The Journal of Machine Learning Research, 9:1871–1874, 2008. [10] J. Friedman, T. Hastie, and R. Tibshirani. Regularization paths for generalized linear models via coordinate descent. Journal of statistical software, 33(1):1, 2010. [11] M. Gustafsson and M. H¨ ornquist. Gene expression prediction by soft integration and the elastic netbest performance of the dream3 gene expression challenge. PLoS One, 5(2):e9134, 2010. [12] T. Hastie, R. Tibshirani, and J. Friedman. The elements of statistical learning, volume 2. Springer, 2009. [13] E. Hazan, T. Koren, and N. Srebro. Beating sgd: Learning svms in sublinear time. In NIPS, pages 1233–1241, 2011. [14] C. Hsieh, K. Chang, C. Lin, S.a Keerthi, and S. Sundararajan. A dual coordinate descent method for large-scale linear svm. In Proceedings of the 25th international conference on Machine learning, pages 408–415. ACM, 2008. [15] M. Jaggi. An equivalence between the lasso and support vector machines. arXiv:1303.1152, 2013. arXiv preprint

[16] T. Joachims. Training linear svms in linear time. In Proceedings of the 12th ACM SIGKDD international conference on Knowledge discovery and data mining, pages 217–226. ACM, 2006. [17] S. Kim, K. Koh, M. Lustig, S. Boyd, and D. Gorinevsky. An interior-point method for large-scale l 1-regularized least squares. Selected Topics in Signal Processing, IEEE Journal of, 1(4):606–617, 2007. [18] A. Krizhevsky, I. Sutskever, and G. Hinton. Imagenet classiﬁcation with deep convolutional neural networks. In NIPS, pages 1097–1105, 2012. [19] J. Langford and B. Zadrozny. Relating reinforcement learning performance to classiﬁcation performance. In ICML, pages 473–480, 2005. [20] S. Lazebnik, C. Schmid, and J. Ponce. Beyond bags of features: Spatial pyramid matching for recognizing natural scene categories. In CVPR, volume 2, pages 2169–2178, 2006.

9

[21] A. Navia-V´ azquez, D. Gutierrez-Gonzalez, E. Parrado-Hern´ andez, and J.J. Navarro-Abellan. Distributed support vector machines. Neural Networks, IEEE Transactions on, 17(4):1091–1097, 2006. [22] F. Pereira, T. Mitchell, and M. Botvinick. Machine learning classiﬁers and fmri: a tutorial overview. Neuroimage, 45(1):S199–S209, 2009. [23] J. Platt et al. Sequential minimal optimization: A fast algorithm for training support vector machines. technical report msr-tr-98-14, Microsoft Research, 1998. [24] M. Schmidt. Least squares optimization with l1-norm regularization. CS542B Project Report, 2005. [25] B. Sch¨ olkopf and A. Smola. Learning with kernels, 2002. [26] S. Tyree, J. Gardner, K.Q. Weinberger, K. Agrawal, and J. Tran. Parallel support vector machines in practice. arXiv preprint arXiv:1404.1066, 2014. [27] Z. Xu, K.Q. Weinberger, and O. Chapelle. The greedy miser: Learning under test-time budgets. In ICML, pages 1175–1182, 2012. [28] H. Zou and T. Hastie. Regularization and variable selection via the elastic net. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 67(2):301–320, 2005.

10

